WEBVTT

1
00:00:14.592 --> 00:00:20.736
Last time on Cucumber School

we showed you how to use
example mapping to facilitate conversations

2
00:00:20.992 --> 00:00:25.344
between stakeholders before starting workon a new user story

3
00:00:25.600 --> 00:00:31.744
We finished the lesson on a technical note,
showing you how to extract

a layer of support code from your
step definitions

4
00:00:32.000 --> 00:00:36.352
to keep your Cucumber code easy -
and cost-effective - to maintain

5
00:00:37.376 --> 00:00:43.520
We’re going to keep things technical
in this lesson.

Remember that bug we spotted right back at
the beginning of lesson seven

6
00:00:43.776 --> 00:00:48.896
where the user was over-charged
if they mentioned “buy”

several times in the same message?

7
00:00:49.152 --> 00:00:52.480
It's time to finally knuckle down and fix it

8
00:00:53.248 --> 00:00:59.392
As we do so, you’re going to get
some more experience

9
00:00:59.648 --> 00:01:00.672
of the inner and outer TDD loops that
we first introduced you to in lesson five

10
00:01:00.928 --> 00:01:06.816
We’ll learn about mock objects,
and explore the difference between

unit tests and acceptance tests

11
00:01:07.072 --> 00:01:08.864
and learn the value of each

12
00:01:09.632 --> 00:01:13.984
If you’re someone who doesn’t normally
dive deep into code, try not to worry

13
00:01:14.496 --> 00:01:20.640
We’ll keep the example from moving too fast,
and we hope you’ll find it educational to see

how different kinds of tests
complement each other in helping you

14
00:01:20.896 --> 00:01:25.248
to build a quality product

15
00:01:26.528 --> 00:01:31.392
Let’s work outside-in and start by
tidying up the Gherkin specification

16
00:01:31.904 --> 00:01:37.024
Right now, the scenario is still in the raw form
it was in when the bug was first reported

17
00:01:37.536 --> 00:01:40.864
with a name that references an ID
in our bug tracking system

18
00:01:41.888 --> 00:01:45.984
This doesn’t make for very good documentation
about the intended behaviour

19
00:01:47.264 --> 00:01:51.872
Using our Friends Episode naming convention
that we introduced in lesson 7

20
00:01:52.384 --> 00:01:55.712
we can come up with a more expressive name
for this scenario

21
00:01:56.480 --> 00:01:57.504
How about:

22
00:01:58.016 --> 00:02:02.880
the one where Sean mentions “buy”
several times in the same shout?

23
00:02:04.672 --> 00:02:07.232
You might be worried about losing this bug ID

24
00:02:07.744 --> 00:02:09.024
We could keep it in

25
00:02:09.536 --> 00:02:15.680
a comment, a tag, or in the description
of the Scenario if we wanted to

28
00:02:16.448 --> 00:02:20.288
If your team likes to keep track of such things,
feel free to do that

29
00:02:21.312 --> 00:02:23.616
We’d prefer to consign the bug to history -

30
00:02:23.872 --> 00:02:27.200
what matters to us
is how the software behaves today, 

31
00:02:27.456 --> 00:02:29.504
not how it got to be that way

32
00:02:31.552 --> 00:02:35.648
We think the values in the example could be
changed to make it a little more expressive

33
00:02:36.160 --> 00:02:42.304
If we start Sean off with 100 credits,
and end him with 95

34
00:02:42.560 --> 00:02:46.400
it more clearly illustrates the rule that
only five credits should be deducted

35
00:02:48.704 --> 00:02:54.848
Talking of which

36
00:02:55.104 --> 00:02:55.616
let’s also update the rule to make it explicit
that you lose 5 credits per shout

37
00:02:57.408 --> 00:02:58.432
Good

38
00:02:59.200 --> 00:03:04.832
Now let’s run our improved scenario,
using the @todo tag, and go hunting for that bug

39
00:03:06.880 --> 00:03:09.952
OK, well we can see our scenario failing

40
00:03:10.464 --> 00:03:12.512
but where do we need to go to fix it?

41
00:03:14.048 --> 00:03:20.192
Luckily, our system is pretty small,
and we remember that all the

42
00:03:20.448 --> 00:03:23.264
premium account behaviour is implemented in
the Network class, so let’s go and look there

43
00:03:24.800 --> 00:03:32.224
Well, that broadcast method is pretty complex,
but I suppose the bug must be in there somewhere

45
00:03:32.480 --> 00:03:34.784
Let’s try to pin it down with a unit test

46
00:03:36.576 --> 00:03:38.880
Oh dear, oh dear:

47
00:03:39.392 --> 00:03:44.768
This file does not contain any tests for
the premium account behaviour!

48
00:03:45.024 --> 00:03:51.168
It looks like when that so-called
hot-shot ninja rockstar subcontractor, Stevie

49
00:03:51.424 --> 00:03:57.568
hacked in the first version of premium accounts,
he drove everything from that

50
00:03:58.592 --> 00:04:00.896
one great big Cucumber scenario,
and never wrote any unit tests

51
00:04:01.664 --> 00:04:03.200
Why is this a problem?

52
00:04:04.480 --> 00:04:09.600
Well, think about each automated test you write
as warning light that you’re fitting to your system

53
00:04:10.112 --> 00:04:13.952
Acceptance tests are warning lights
that make sense to business people:

54
00:04:14.464 --> 00:04:16.000
when they fail,

54
00:04:16.000 --> 00:04:20.607
they tell you what functionality a user
will not be able to enjoy because of the bug

55
00:04:21.887 --> 00:04:27.775
What a unit test does is give the programmers
an indication about why the bug has occurred

56
00:04:28.543 --> 00:04:32.895
Ideally, whenever you see an acceptance test’s
warning light flash

57
00:04:33.151 --> 00:04:39.295
there should be at least one corresponding
unit test flashing too,

pointing the developers to
the source of the problem

58
00:04:40.831 --> 00:04:46.207
If you don’t have any unit tests,
you’re left guessing where the problem lies

59
00:04:46.719 --> 00:04:50.815
In a big system,
this can be a serious waste of time

61
00:04:51.839 --> 00:04:57.215
So the responsible thing to do at this point is to
retrofit some unit tests for the Network class

62
00:04:57.983 --> 00:05:03.615
We’ll start with its existing behaviour,
then go on to test-drive the

behaviour we need to fix our bug

63
00:05:04.639 --> 00:05:10.783
Let’s write a test case for deducting five credits
when the word “buy” is mentioned once

64
00:05:12.831 --> 00:05:18.975
All our existing tests use a
test double or mock object

65
00:05:19.231 --> 00:05:19.999
to represent the instance of Person
that the Network collaborates with

66
00:05:20.767 --> 00:05:23.071
So let’s go with that and try to do the same here

67
00:05:24.351 --> 00:05:27.679
First we need a mock object to represent Sean

68
00:05:29.727 --> 00:05:33.055
And we’ll need to broadcast a
message containing the word “buy”

69
00:05:35.103 --> 00:05:36.127
What next?

70
00:05:37.919 --> 00:05:42.015
Well we need to assert that Sean is told
to reduce his credits

71
00:05:43.551 --> 00:05:49.695
In the deductCredits method here,
we’re calling the credits setter

setting it to five less than the current value

72
00:05:49.951 --> 00:05:56.095
So we need to stub the attribute getter with
say 100 credits, and then check

73
00:05:56.351 --> 00:05:57.375
that the setter is called with 95

74
00:05:57.887 --> 00:05:59.423
Here's how we do that

75
00:06:02.751 --> 00:06:04.799
This test is a real pain to write

76
00:06:06.847 --> 00:06:09.407
Mock objects are a design tool

77
00:06:09.919 --> 00:06:13.247
They’re intended to be used when
constructing new code

78
00:06:13.759 --> 00:06:18.111
to throw together a lightweight sketch
of a collaborating object

79
00:06:18.879 --> 00:06:21.183
When you’re focused on building a Network

80
00:06:21.439 --> 00:06:24.255
and you think it needs to
collaborate with a Person

81
00:06:24.767 --> 00:06:28.863
it would slow you down to have to stop
and go off to build the actual Person class

82
00:06:29.375 --> 00:06:35.007
It’s often quicker to use a mock object to
hash out your idea of roughly

what Person might look like

83
00:06:35.263 --> 00:06:38.591
leaving you to stay focussed on the task at hand

84
00:06:39.359 --> 00:06:42.431
As you do this, you’ll find yourself -

85
00:06:42.687 --> 00:06:43.967
As we just did

86
00:06:44.223 --> 00:06:48.831
having to specify how you want
the two objects to interact

87
00:06:49.599 --> 00:06:55.743
If you think about it, this interaction -
the way they talk to each other at runtime -

88
00:06:55.999 --> 00:06:59.071
is the true behaviour of these objects

89
00:07:00.095 --> 00:07:06.239
Remember back in lesson 5, Loops,
where we explained that acceptance tests

90
00:07:06.495 --> 00:07:12.639
help you build the right thing,
and unit tests help you build the thing right?

92
00:07:13.151 --> 00:07:19.295
In other words, acceptance tests help us to
explore the problem domain,

93
00:07:19.551 --> 00:07:21.599
and unit tests help us to explore the solution

94
00:07:22.879 --> 00:07:28.767
When you drive your development from tests,
the unit tests can give you feedback

about the design of your solution

95
00:07:29.279 --> 00:07:35.423
If it’s easy to take an individual object and
plug it into your tests

your design is likely to be nicely modular,

96
00:07:35.679 --> 00:07:38.751
which means it will be easier
to change in the future

97
00:07:39.263 --> 00:07:44.639
If it’s awkward, that’s a signal
there’s a problem with your design

98
00:07:45.151 --> 00:07:49.247
We call this listening to the tests

99
00:07:51.551 --> 00:07:57.695
One alternative to using mocks would be to
use a real instance of Person

instead of the mock object

100
00:07:59.231 --> 00:08:00.767
This is very tempting

101
00:08:01.023 --> 00:08:07.167
By testing Person and Network
as one integrated lump,

102
00:08:07.423 --> 00:08:08.959
we don’t have to fuss about exactly
how they communicate about Sean’s credits

103
00:08:09.471 --> 00:08:13.567
All we have to do is check how many credits
he has left over at the end

104
00:08:14.847 --> 00:08:18.943
But this seductive solution papers over
the cracks in our design

105
00:08:19.711 --> 00:08:25.855
When you use mocks, you put the microscope on the
interaction between an object and its collaborators

106
00:08:26.111 --> 00:08:29.183
This gives you feedback about
how coupled those objects are

107
00:08:29.695 --> 00:08:35.071
A lot of chatter going back and forth like this
suggests they’re getting tangled up together

108
00:08:35.839 --> 00:08:41.983
So the fact that it’s awkward to use mocks here
is not because mocks are bad

or because we’re bad at using mocks:

109
00:08:43.007 --> 00:08:45.567
it’s feedback from the code

110
00:08:46.591 --> 00:08:52.479
Let’s listen to the tests and try to respond
to this pain instead of ignoring it

112
00:08:54.015 --> 00:08:55.807
Let’s take stock a little bit

113
00:08:56.319 --> 00:09:00.159
We’re trying to fix that bug about
multiple mentions of the word “buy”

114
00:09:00.415 --> 00:09:06.303
but first we’re retrofitting unit tests for the
premium account behaviour in the Network class

115
00:09:07.071 --> 00:09:13.215
It will be easier to see what tests are missing
if we reorganize the unit tests by

116
00:09:13.471 --> 00:09:14.751
Network’s responsibilities

117
00:09:16.031 --> 00:09:18.591
They basically fall into two categories

118
00:09:19.615 --> 00:09:25.759
These ones here are to do with the
responsibility of broadcasting to listeners

119
00:09:26.015 --> 00:09:27.039
so let’s group them in a different section
of our test class

120
00:09:28.831 --> 00:09:32.927
Now we have our new test, which is about
charging for shouts

121
00:09:34.207 --> 00:09:36.255
This last one here is a bit weird

122
00:09:36.767 --> 00:09:39.583
It’s sort of about broadcasting to listeners

123
00:09:39.839 --> 00:09:43.167
but it has this odd hack in it
which needs further investigation

124
00:09:44.191 --> 00:09:50.335
This test is quite obscure,
and seems to be attempting to cover

several aspects of Network’s behaviour
all at once

125
00:09:51.615 --> 00:09:57.503
Let’s document those individual behaviours
as new tests and we can come back

to deal with this one later

126
00:09:59.807 --> 00:10:05.951
We can see we’ll need something similar

under the responsibility of
broadcasting to listeners,

127
00:10:06.207 --> 00:10:12.351
to ensure long messages aren’t broadcast for
people with no credits,

128
00:10:12.607 --> 00:10:14.399
so we can express that using
a test annotated with @Ignore for the time being

129
00:10:15.167 --> 00:10:16.959
We can fill this out later

130
00:10:18.751 --> 00:10:23.615
It’s clear we’ll also need to test that
we charge two credits for an over-long message

131
00:10:24.383 --> 00:10:26.943
Let's add another ignores test for that

132
00:10:29.503 --> 00:10:33.855
Once those two tests are implemented,
we won’t need this obscure one any more

133
00:10:34.367 --> 00:10:40.511
We’re not confident enough to just remove it
until we’ve seen those tests fleshed out

134
00:10:40.767 --> 00:10:42.303
so we can mark it as ignore for now

135
00:10:43.327 --> 00:10:46.911
That will remind us we need to
come back and clean this up soon

136
00:10:47.679 --> 00:10:53.567
At this point it is becoming clear that
Network has too many responsibilities

137
00:10:54.335 --> 00:10:57.663
We have two different sources of feedback
telling us this

138
00:10:58.943 --> 00:11:03.807
With the unit tests laid out by responsibility
we can see more clearly

139
00:11:04.063 --> 00:11:08.415
that while broadcasting to listeners
is a responsibility that fits

140
00:11:08.671 --> 00:11:14.047
there’s no real reason why the Network
needs be responsible for charging for shouts

141
00:11:16.095 --> 00:11:17.119
Secondly, the communication protocol
between Network and Person

143
00:11:20.959 --> 00:11:24.287
exposed by the mocks, is very noisy:

144
00:11:25.055 --> 00:11:31.199
we’re making lots of method calls to Person
in order to determine whether they can

afford the shout and to deduct payment

145
00:11:31.455 --> 00:11:37.599
First Sean calls Network#broadcast

146
00:11:37.855 --> 00:11:43.999
then Network asks Sean how many credits he has

147
00:11:44.255 --> 00:11:50.399
then Network tells Sean

the new value of his credits,
with the fee for the message deducted

148
00:11:50.655 --> 00:11:55.519
then Network asks Sean
how many credits he has again,

in order to check whether he can afford
to send the message!

149
00:11:56.799 --> 00:12:02.943
We could get all sad and angry that if only

150
00:12:03.199 --> 00:12:04.223
we’d test-driven this code in the first place

151
00:12:04.479 --> 00:12:06.015
we might have got this feedback sooner,
but that would be futile:

152
00:12:06.271 --> 00:12:08.831
it's not too late to clean this code up!

153
00:12:09.343 --> 00:12:14.719
How about we make Sean responsible for
organising his own payment?

154
00:12:15.999 --> 00:12:20.351
Instead of rewriting this code
let’s see if we can refactor it

155
00:12:20.863 --> 00:12:25.471
When refactoring, it’s crucial not to
break existing functionality

156
00:12:25.983 --> 00:12:30.079
so we’ll rely on our tests to warn us
if we make a mistake

157
00:12:31.871 --> 00:12:33.919
We’ll work in small steps

158
00:12:34.431 --> 00:12:40.575
We may temporarily break some unit tests
as the implementation shifts

159
00:12:40.831 --> 00:12:42.879
but the acceptance tests should be
passing all the way through

160
00:12:43.135 --> 00:12:45.183
if everything goes according to plan

161
00:12:46.719 --> 00:12:47.487
Ready?

162
00:12:49.279 --> 00:12:53.631
We’ll start by moving the
deductCredits method onto Person

163
00:12:54.399 --> 00:13:00.543
As a baby-step, we’ll make it public,
so we can just continue to call it

164
00:13:00.799 --> 00:13:01.311
from Network’s broadcast method for now

165
00:13:02.079 --> 00:13:04.383
That should keep the acceptance tests passing

166
00:13:10.015 --> 00:13:10.783
Good

167
00:13:12.063 --> 00:13:17.439
Now let’s make Sean responsible for
deducting his own credits, as he shouts

168
00:13:23.327 --> 00:13:29.471
We can move over this whole responsibility of
charging for shouts from the network specs

169
00:13:29.727 --> 00:13:30.751
to the person specs

170
00:13:33.311 --> 00:13:35.871
We’ll need to adjust the test like this...

171
00:13:43.551 --> 00:13:45.599
and we’re back to green!

172
00:13:47.135 --> 00:13:48.671
Let’s refactor some more

173
00:13:49.183 --> 00:13:55.327
Because all this code is running
within the shouter object now

we don’t need to pass around this
instance of Person anymore

174
00:13:55.583 --> 00:13:58.655
and we can access the
credits instance variable here, directly

175
00:14:00.191 --> 00:14:03.007
We can make deduct credits private now

176
00:14:04.543 --> 00:14:09.663
We don’t need to pass short enough
around as a variable

we can just do the logic inline here

177
00:14:17.599 --> 00:14:18.623
Great, now the code in Network#broadcast
is much cleaner

178
00:14:19.391 --> 00:14:22.975
We still have these pending unit tests
we need to sort out

179
00:14:23.231 --> 00:14:28.607
Let’s start in Person, by fleshing out
this test about charging for long messages

180
00:14:46.527 --> 00:14:47.551
That's better

181
00:14:48.319 --> 00:14:51.903
Let’s just make it fail quickly,
to check that we can trust it

182
00:15:07.775 --> 00:15:08.799
Okay

183
00:15:10.335 --> 00:15:13.663
now we can tackle these two
ignored unit tests in Network

184
00:15:14.431 --> 00:15:18.271
Let’s step back for a second
and consider the rule we’re implementing here

185
00:15:19.295 --> 00:15:25.183
This original unit test was simply there
to ensure that long messages were not broadcast:

186
00:15:25.695 --> 00:15:29.279
remember we originally started out
without premium accounts

187
00:15:30.303 --> 00:15:33.887
With the addition of premium accounts,
the rule has changed:

188
00:15:34.399 --> 00:15:40.543
We will broadcast long messages,
but only if the person shouting

has sufficient credits

189
00:15:41.823 --> 00:15:47.711
To implement it, we’ve ended up with
this mind-bending boolean logic

in the broadcast method

190
00:15:48.991 --> 00:15:50.783
It doesn’t have to be like this

191
00:15:51.039 --> 00:15:55.135
This complexity is a sign that
we haven’t modelled the problem well enough yet

192
00:15:56.159 --> 00:16:02.303
Recall that right at the end of lesson 7,
we discovered a

193
00:16:02.559 --> 00:16:05.375
known unknown in our problem domain
and documented it with this question:

194
00:16:05.887 --> 00:16:08.703
what happens when you run out of credits? 

195
00:16:09.983 --> 00:16:15.871
We know you can’t send a long message when
you run out of credits

but what about a message
containing the word ‘buy’?

196
00:16:16.639 --> 00:16:22.271
Perhaps having a complete answer to this question
will help us to resolve this complexity

197
00:16:23.295 --> 00:16:25.343
Let’s check with our product owner

198
00:16:27.135 --> 00:16:31.231
We use a scenario to frame the discussion
with Paula, our product owner

199
00:16:32.767 --> 00:16:35.583
Given Lucy and Sean are
within range of each other -

200
00:16:35.839 --> 00:16:37.887
that’s what these background steps do -

201
00:16:38.655 --> 00:16:40.959
and Sean has bought 4 credits,

202
00:16:41.727 --> 00:16:48.127
when Sean shouts a message
containing the word “buy” then… what?

204
00:16:49.151 --> 00:16:53.503
Sean doesn’t have enough credits,
so presumably Lucy does not hear his message

205
00:16:53.759 --> 00:16:55.039
is that right?

206
00:16:56.319 --> 00:16:58.111
Right, says Paula

207
00:16:59.391 --> 00:17:04.255
And so in that case, Sean should
still have his four credits, correct?

208
00:17:05.023 --> 00:17:06.815
Right again, says Paula

209
00:17:08.351 --> 00:17:14.495
OK, thanks Paula.

So the rule is that we’ll only
send shouts that you can afford

Is that right?

210
00:17:16.799 --> 00:17:22.943
Correct! says Paula.

A person can’t send a premium shout
unless they have enough credits to pay for it

211
00:17:24.735 --> 00:17:30.111
Now we understand the business rule,
let’s automate this scenario

and drive out the behaviour

212
00:17:34.719 --> 00:17:40.863
First we need to match this new step
where we check Lucy does not hear Sean’s message

213
00:17:41.631 --> 00:17:44.447
We have a very similar one here for Larry.

214
00:17:44.959 --> 00:17:48.799
We can use a capture group to make it more generic

215
00:17:49.567 --> 00:17:56.735
Instead of a wildcard though,

we can use pipes to specify
the alternative values we expect here

217
00:17:58.271 --> 00:18:00.063
We capture the listener name,

218
00:18:00.319 --> 00:18:04.159
then use that here
when fetching the instance of Person

219
00:18:05.951 --> 00:18:18.49500:18:06.719
Right, now we have a failing acceptance test
which should be passing once we’ve resolved this

221
00:18:18.751 --> 00:18:21.823
Let’s have a think about where
this behaviour should go

222
00:18:23.359 --> 00:18:27.967
If we give the responsibility for checking
affordability to the Person doing the shouting

223
00:18:28.223 --> 00:18:31.039
then Network doesn’t need to
care about credits at all

224
00:18:31.295 --> 00:18:33.343
which will simplify things nicely

225
00:18:35.391 --> 00:18:38.207
Let’s start with a new unit test for Person then

226
00:18:41.279 --> 00:18:44.095
We’ll set up Sean with only one credit -

227
00:18:44.351 --> 00:18:46.911
not enough to afford to send a long message -

228
00:18:47.167 --> 00:18:51.007
and assert that the broadcast method
is not called on Network

229
00:18:51.775 --> 00:18:54.335
Then we try to shout the long message

230
00:19:02.271 --> 00:19:08.415
This fails of course, because at the moment
Person doesn’t make this check

231
00:19:08.671 --> 00:19:09.183
so the broadcast method is called every time

232
00:19:10.207 --> 00:19:12.767
We’re at Red in the TDD cycle

233
00:19:13.023 --> 00:19:15.071
Next stop: green!

235
00:19:16.095 --> 00:19:22.239
To make this pass we need to know
how much the shout is going to cost

before we send it

236
00:19:23.007 --> 00:19:29.663
That knowledge is in the deductCredits method
which actually does two tasks at the same time:

238
00:19:29.919 --> 00:19:35.807
it works out the cost of the message, and
it deducts that cost from the person’s balance

239
00:19:37.599 --> 00:19:43.743
Let’s tease those two tasks apart,
first calculating the cost of the shout

240
00:19:43.999 --> 00:19:46.047
then deducting that cost from the credits

241
00:19:47.583 --> 00:19:51.679
Now we can extract a method that calculates
the cost of the message

242
00:19:56.543 --> 00:20:01.663
Then finally we can use that method
to check whether the message is affordable

243
00:20:09.599 --> 00:20:11.647
and our unit test is passing

244
00:20:12.415 --> 00:20:13.439
Great

245
00:20:15.487 --> 00:20:20.351
And I suppose our acceptance test for
the affordability rule should be passing now too 

246
00:20:21.119 --> 00:20:26.495
It is!

We’re green, so it’s refactoring time again! 

247
00:20:26.751 --> 00:20:32.639
Now we can give that messy old test in
Network’s unit tests the treatment it deserves

248
00:20:33.151 --> 00:20:35.711
because this behaviour is now on Person

249
00:20:36.479 --> 00:20:38.527
We won’t be needing this pending test

250
00:20:39.551 --> 00:20:43.391
Deleting code is my favourite
kind of refactoring!

251
00:20:43.903 --> 00:20:49.535
Let’s keep going and strip back all that
crazy boolean login in Network#broadcast

252
00:20:50.303 --> 00:20:56.447
I think we can just remove this whole clause
about the message being too short

or having enough credits or whatever

253
00:20:56.703 --> 00:20:59.263
Let’s try it and see what the tests tell us

254
00:21:00.799 --> 00:21:03.359
Excellent, much better!

255
00:21:08.223 --> 00:21:11.039
Now, can we do any refactoring in Network?

256
00:21:12.063 --> 00:21:17.952
This method would read a lot better if
we extract a method that returns only

the listeners within range of the shouter

257
00:21:18.208 --> 00:21:19.488
Let’s do that

258
00:21:37.408 --> 00:21:42.784
We don’t need to use this shouterLocation
temporary variable either

Let’s inline it

259
00:21:43.552 --> 00:21:48.672
OK. The code is nice and clean,
and all our tests are passing... 

261
00:21:48.928 --> 00:21:50.464
except for one:

262
00:21:50.976 --> 00:21:52.256
that bug!

263
00:21:52.512 --> 00:21:56.864
It can’t escape us any longer.
Let's trap it with a unit test

264
00:21:57.632 --> 00:22:01.984
We know the responsibility for charging
for shouts lies in Person

265
00:22:02.240 --> 00:22:04.544
so that’s where to add the unit test

266
00:22:23.232 --> 00:22:26.304
Have you already spotted
where we need to make the change? 

267
00:22:27.328 --> 00:22:30.144
Here, in the cost_of(message) method,

268
00:22:30.400 --> 00:22:35.520
the code will add five credits to the cost
each time it finds the word “buy” in the message

269
00:22:36.032 --> 00:22:40.384
If we change the code like this,
it should be working as expected

271
00:22:43.968 --> 00:22:44.992
It is!

272
00:22:45.248 --> 00:22:46.272
Great stuff

273
00:22:47.040 --> 00:22:50.112
Although we’ve called this
video series Cucumber School

274
00:22:50.368 --> 00:22:56.512
you’ve probably noticed by now
that we’re teaching you

275
00:22:56.768 --> 00:22:58.560
a whole range of skills and ideas that
we on the Cucumber team use to develop software

276
00:22:59.584 --> 00:23:05.216
Not just skills with Cucumber,
but skills with the whole of

Behaviour-Driven Development

277
00:23:06.240 --> 00:23:11.360
BDD blurs the lines between traditional roles
like tester and developer

278
00:23:11.616 --> 00:23:17.760
In our ideal world,
everyone on the team - not just testers -

279
00:23:18.016 --> 00:23:21.600
is responsible for quality, and we all
try to test it as much as possible

280
00:23:22.624 --> 00:23:28.768
Having good automated tests
frees up testers to do more

281
00:23:29.024 --> 00:23:29.792
interesting, interactive, exploratory testing

282
00:23:31.584 --> 00:23:36.192
We use our tests as a guide to help us
design a solution that models the problem well

283
00:23:36.704 --> 00:23:42.592
A better model in your solution can make
whole categories of bugs go away forever

284
00:23:43.360 --> 00:23:49.504
We saw that in this lesson

when we moved the responsibility
for charging for shouts from Network to Person

285
00:23:49.760 --> 00:23:55.904
and the issues around what happened when you run
out of credit suddenly became easy to resolve

286
00:23:57.440 --> 00:24:03.584
Getting the right balance between

fine-grained unit tests and
broader full-stack tests

287
00:24:03.840 --> 00:24:08.960
is critically important to having fast,
useful feedback from your test suite

288
00:24:09.472 --> 00:24:12.288
We’ll explore this more in the next lesson

289
00:24:13.568 --> 00:24:16.896
See you next time, on Cucumber School

290
00:24:16.000 --> 00:24:18.000
Captions created by Jayson Smith for Cucumber Ltd.
