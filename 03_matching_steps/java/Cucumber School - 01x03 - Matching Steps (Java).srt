1
00:00:15,620 --> 00:00:18,700
Welcome back to the 3rd lesson of Cucumber School

2
00:00:19,460 --> 00:00:21,080
I hope you're having fun!

3
00:00:22,280 --> 00:00:24,940
Last time we showed you the
fundamental components

4
00:00:24,940 --> 00:00:27,320
of a Cucumber test suite

5
00:00:27,320 --> 00:00:30,460
and how we use them to drive out a solution

6
00:00:30,460 --> 00:00:31,740
test first

7
00:00:33,180 --> 00:00:41,720
First, we specified the behaviour we wanted
using a Gherkin scenario in a feature file

8
00:00:42,760 --> 00:00:48,680
Then we wrote step definitions to translate
the plain English from our scenario

9
00:00:48,680 --> 00:00:50,940
into concrete actions in code

10
00:00:52,480 --> 00:00:58,520
The step definitions then exercised our
very basic domain model

11
00:00:58,520 --> 00:01:00,160
for the Shouty application

12
00:01:01,860 --> 00:01:05,740
We tend to think of the code that
actually pokes around with the system

13
00:01:05,740 --> 00:01:09,340
as distinct from the step definitions

14
00:01:09,340 --> 00:01:12,960
so we’ve drawn an extra box labelled
'automation code'

15
00:01:16,160 --> 00:01:20,280
Automation code can do
almost anything to your application:

16
00:01:20,280 --> 00:01:26,340
it can drive a web browser around your site
make HTTP requests to a REST API

17
00:01:26,340 --> 00:01:31,120
or -- as you’ve already seen --
drive a domain model directly

18
00:01:32,160 --> 00:01:35,744
Automation code is a big topic
that we’ll come back to

19
00:01:36,512 --> 00:01:40,096
First we want to concentrate on step definitions

20
00:01:40,860 --> 00:01:46,740
Good step definitions are important because
they enable the readability of your scenarios

21
00:01:47,640 --> 00:01:51,980
The better you are at matching
plain language phrases from Gherkin

22
00:01:51,980 --> 00:01:56,240
the more expressive you can be
when writing scenarios

23
00:01:56,740 --> 00:02:02,220
Teams who do this well refer to their
features as living documentation -

24
00:02:02,220 --> 00:02:05,960
a specification document that
never goes out of date

25
00:02:06,460 --> 00:02:12,720
In Cucumbe,r we use regular expressions to match
plain language phrases from Gherkin steps

26
00:02:14,400 --> 00:02:18,900
Regular expressions have quite an
intimidating reputation

27
00:02:18,900 --> 00:02:22,780
In fact, there are only
a handful of patterns you need

28
00:02:22,780 --> 00:02:25,680
to be able to do almost anything
with regular expressions

29
00:02:25,680 --> 00:02:28,120
No need to be scared

30
00:02:28,120 --> 00:02:31,120
We’ll cover all of those patterns
in this lesson

31
00:02:31,120 --> 00:02:34,120
Let’s look at the Shouty scenario
from the last lesson

32
00:02:35,140 --> 00:02:38,160
As Cucumber starts to execute this feature,

33
00:02:38,160 --> 00:02:44,760
it will come to the first step of the scenario
'Given Lucy is 15 metres from Sean'

34
00:02:44,760 --> 00:02:50,780
and say to itself 'now - do I have any
step definitions that match the phrase:

35
00:02:50,780 --> 00:02:53,580
Lucy is 15 metres from Sean?'

36
00:02:55,616 --> 00:03:00,736
The most simple regular expression that
would match that step is this one

37
00:03:02,520 --> 00:03:04,140
That’s pretty simple isn’t it?

38
00:03:05,080 --> 00:03:07,880
Regular expressions are just patterns

39
00:03:07,880 --> 00:03:12,000
and the most simple pattern
you can use is a perfect match

40
00:03:14,040 --> 00:03:18,140
In Java, we can use this pattern
to make a step definition like this

41
00:03:20,680 --> 00:03:24,220
We use an annotation to link
the regular expression to the Java method

42
00:03:25,300 --> 00:03:27,580
We can call the method whatever we like

43
00:03:27,580 --> 00:03:30,520
but it make sense to
have it be something meaningful

44
00:03:31,960 --> 00:03:36,120
We use underscores rather than
the standard camel case naming

45
00:03:36,120 --> 00:03:38,960
so that the method reads
just like a sentence

46
00:03:40,700 --> 00:03:41,920
Notice that

47
00:03:41,920 --> 00:03:46,540
unlike the snippet generated by Cucumber 
that we used in the previous lesson

48
00:03:46,540 --> 00:03:49,320
this step definition doesn’t take an argument

49
00:03:50,900 --> 00:03:53,920
To capture interesting values
from our step definitions

50
00:03:53,920 --> 00:03:56,520
we can use what’s called a capture group

51
00:03:57,700 --> 00:04:02,540
You just surround the interesting part
of the pattern with parentheses, like this

52
00:04:04,140 --> 00:04:06,660
Now we’re capturing that value as an argument

53
00:04:07,860 --> 00:04:12,220
The value 15 will be passed
to our code automatically by Cucumber

54
00:04:14,920 --> 00:04:17,580
That’s not much better yet though -

55
00:04:17,580 --> 00:04:22,840
this step definition will only match
if the step specifies a distance of 15 metres

56
00:04:23,640 --> 00:04:26,860
If we want to set Lucy and Sean
a different distance apart

57
00:04:26,860 --> 00:04:28,320
this pattern won’t match

58
00:04:29,240 --> 00:04:30,440
Let's try it and see

59
00:04:32,920 --> 00:04:36,520
Yep, it’s showing this step as undefined.

60
00:04:36,520 --> 00:04:39,060
Hmm... So that’s not much use

61
00:04:39,740 --> 00:04:43,800
We need to make our regular expression
a little bit more flexible

62
00:04:44,700 --> 00:04:47,520
We can do this using a wildcard

63
00:04:49,820 --> 00:04:54,240
There are a few different ways to specify
a wildcard in a regular expression

64
00:04:55,260 --> 00:04:58,140
One of the simplest is alternation

65
00:04:58,140 --> 00:05:02,060
where we express different options
separated by a pipe character (|), like this

66
00:05:06,020 --> 00:05:08,920
Now we could use either of those
values in the step

67
00:05:08,920 --> 00:05:13,320
and this definition will still match
and pass the value into our code

68
00:05:14,520 --> 00:05:18,660
Alternation is useful when
you have a fixed set of values

69
00:05:18,660 --> 00:05:21,780
but normally you’ll want something a bit looser

70
00:05:24,080 --> 00:05:27,600
The dot (.) is a metacharacter

71
00:05:27,600 --> 00:05:30,860
which means it has magical powers
in a regular expression

72
00:05:31,660 --> 00:05:36,820
It means match any single character

73
00:05:36,820 --> 00:05:39,640
so we could change our step definition
to this instead

74
00:05:41,940 --> 00:05:45,800
Now we’ll match a step with
any two-digit distance

75
00:05:46,500 --> 00:05:49,440
That’s an improvement
but we can still do better

76
00:05:50,340 --> 00:05:54,760
Remember, the dot will match
any character at all

77
00:05:54,760 --> 00:05:57,440
so it would also match letters
as well as numbers

78
00:05:58,440 --> 00:06:00,500
We’ll come back to this problem in a minute

79
00:06:00,500 --> 00:06:04,620
More pressing is that we are limited
to using two-digit distances

80
00:06:05,440 --> 00:06:09,920
What if we wanted to place them
2 metres apart, or 100?

81
00:06:11,840 --> 00:06:16,240
To fix that, we need to use a modifier

82
00:06:20,320 --> 00:06:26,080
In regular expressions, a repetition modifier
comes after a character

83
00:06:26,080 --> 00:06:29,040
and tells us how many times
that character can appear

84
00:06:29,840 --> 00:06:32,180
The most flexible modifier is the star (*)

85
00:06:33,320 --> 00:06:34,760
We could use it like this

86
00:06:36,760 --> 00:06:40,820
The star means any number of times

87
00:06:40,820 --> 00:06:46,440
so dot-star (.*) means any character
any number of times

88
00:06:47,400 --> 00:06:48,760
That’s pretty flexible!

89
00:06:49,760 --> 00:06:53,560
Actually, maybe a bit too flexible

90
00:06:54,220 --> 00:06:58,080
Remember the dot will match any character
including letters

91
00:06:58,660 --> 00:07:02,840
Combined with the star
we could end up matching a step like this:

92
00:07:05,460 --> 00:07:12,460
Hmm... Our capture would gobble up everything
up until the words metres from Sean

93
00:07:14,160 --> 00:07:16,700
Look what our distance argument ends up as!

94
00:07:18,600 --> 00:07:20,440
We need to be more specific

95
00:07:21,300 --> 00:07:25,360
Luckily, the dot isn’t the only
special character we can use

96
00:07:28,500 --> 00:07:32,400
Regular expressions allow you
to define character classes

97
00:07:33,620 --> 00:07:36,460
A character class is
a range of characters

98
00:07:36,460 --> 00:07:40,200
one of which must match at
that point in the pattern

99
00:07:41,600 --> 00:07:45,580
You just place all of the acceptable characters
together inside square brackets

100
00:07:46,640 --> 00:07:50,740
So we can replace our dot with
a character class that accepts

101
00:07:50,740 --> 00:07:55,340
any single digit from 0 to 9, like this

102
00:08:03,020 --> 00:08:08,240
Now we’re accepting any digit from 0-9
any number of times

103
00:08:08,240 --> 00:08:09,880
But we can do better than that

104
00:08:10,900 --> 00:08:15,700
With a continuous range of characters
we don’t need to specify each one

105
00:08:16,900 --> 00:08:20,280
That works just the same, and reads a bit better

106
00:08:22,040 --> 00:08:24,580
For common character classes like digits

107
00:08:24,580 --> 00:08:28,820
there are a few shorthand character classes
that you can use

108
00:08:29,560 --> 00:08:32,660
For digits, you can use a backslash-d (\d)

109
00:08:34,640 --> 00:08:37,740
When we write a regular expression in Java

110
00:08:37,740 --> 00:08:43,520
we have to escape backslashes and double quotes
with an additional backslash

111
00:08:44,320 --> 00:08:48,860
So when you see two backslashes,
think of them as a single one

112
00:08:49,820 --> 00:08:54,060
Maybe you find that’s just made your
regular expression more cryptic

113
00:08:54,060 --> 00:08:56,360
It’s something of a matter of taste

114
00:08:56,360 --> 00:08:59,280
but there are only a few of these
to learn if you’re interested

115
00:09:00,000 --> 00:09:02,040
Here are the most useful ones:

116
00:09:03,880 --> 00:09:05,800
\d is for digit

117
00:09:07,040 --> 00:09:10,620
\w is for word character

118
00:09:12,280 --> 00:09:15,940
\s is for whitespace:

119
00:09:15,940 --> 00:09:21,200
a space, a tab, or a line break

120
00:09:22,820 --> 00:09:26,160
The star modifier has a subtle flaw:

121
00:09:27,720 --> 00:09:33,580
any number of times includes zero times

122
00:09:34,560 --> 00:09:38,520
We don’t want to match distances with
zero digits in them

123
00:09:41,400 --> 00:09:44,480
This time Cucumber throws an error
and fails our step!

124
00:09:45,240 --> 00:09:48,700
It doesn’t know how to convert
an empty string into an integer!

125
00:09:49,540 --> 00:09:53,620
To fix this, we can use the plus (+) modifier

126
00:09:54,580 --> 00:10:00,060
That means at least once
which is more suitable in this situation

127
00:10:03,900 --> 00:10:06,700
Now that is pretty watertight

128
00:10:08,180 --> 00:10:10,900
We took quite a long time to get here

129
00:10:10,900 --> 00:10:15,380
but on the journey we passed through almost
every feature of regular expressions

130
00:10:15,380 --> 00:10:18,500
you’ll ever need to work with Cucumber

131
00:10:19,800 --> 00:10:22,320
There are just a couple more
we want to tell you about

132
00:10:23,740 --> 00:10:28,200
Don’t go thinking you’re limited to
capturing just one argument from a step

133
00:10:29,360 --> 00:10:34,500
You can use the parentheses as many times
as you like in your pattern

134
00:10:35,100 --> 00:10:41,160
For example, we could make the names of the people
in our step into arguments, like this

135
00:10:44,080 --> 00:10:48,000
Notice that we haven’t used quotation marks ("")
to surround our captures

136
00:10:48,000 --> 00:10:49,540
anywhere in this lesson

137
00:10:51,540 --> 00:10:53,840
There’s nothing mandatory about doing that -

138
00:10:53,840 --> 00:10:56,920
it's just a convention that
many people like to use

139
00:10:56,920 --> 00:11:01,360
but as long as you use a capture group
in your regular expression

140
00:11:01,360 --> 00:11:04,660
Cucumber will pass you the captured value
as an argument

141
00:11:06,660 --> 00:11:12,060
Although it’s important to try to use
consistent terminology in your Gherkin scenarios

142
00:11:12,060 --> 00:11:16,860
to help develop the
ubiquitous language of your domain

143
00:11:16,860 --> 00:11:22,360
you also want scenarios to read naturally
which means allowing a bit of flexibility

144
00:11:24,220 --> 00:11:30,460
Ideally, the language used in scenarios should
never be constrained by your step definitions

145
00:11:31,420 --> 00:11:35,380
Otherwise, they’ll end up sounding 
like they were written by robots

146
00:11:36,860 --> 00:11:39,860
One common example is the problem of plurals

147
00:11:40,980 --> 00:11:44,960
Suppose we want to place Lucy and Sean
just 1 metre apart

148
00:11:46,060 --> 00:11:48,200
This step would not match

149
00:11:50,040 --> 00:11:55,840
Because we’ve used the singular 'metre'
instead of the plural 'metres'

150
00:11:55,840 --> 00:11:57,160
we don’t have a match

151
00:11:58,180 --> 00:11:59,440
What a pain!

152
00:12:00,860 --> 00:12:01,800
Fear not!

153
00:12:02,860 --> 00:12:06,160
We can use another modifier
the question mark (?)

154
00:12:06,160 --> 00:12:09,280
to mark the “s” as optional

155
00:12:10,460 --> 00:12:11,440
Here's how that looks

156
00:12:14,140 --> 00:12:17,820
The question mark is one way to
smooth off some of the rough edges

157
00:12:17,820 --> 00:12:19,440
in your regular expressions

158
00:12:21,400 --> 00:12:25,620
Another trick is to use a non-capturing group

159
00:12:29,900 --> 00:12:31,940
Suppose someone wanted to write this step

160
00:12:34,840 --> 00:12:38,860
The fact that Lucy is standing
doesn't particularly matter

161
00:12:38,860 --> 00:12:42,180
but the people writing this step
like the way it reads, and want to keep it

162
00:12:44,160 --> 00:12:48,200
We can change our regular expression
to allow for both, like this

163
00:12:51,160 --> 00:12:54,500
This is the same as the
alternates we used earlier

164
00:12:55,880 --> 00:12:59,500
We use a list of alternate phrases
separated by a pipe

165
00:13:00,880 --> 00:13:04,740
This time we start with
the question-mark-colon (?:)

166
00:13:04,740 --> 00:13:07,620
to indicate that the group is non-capturing

167
00:13:08,780 --> 00:13:13,500
Otherwise we’d be passed the value
of whichever alternate matched

168
00:13:13,500 --> 00:13:15,320
which isn’t really interesting to us

169
00:13:18,140 --> 00:13:19,280
One final thing

170
00:13:20,220 --> 00:13:24,900
You might have noticed that the snippets
Cucumber prints out for undefined steps

171
00:13:24,900 --> 00:13:27,940
start with a caret (^) and end with a dollar ($)

172
00:13:29,300 --> 00:13:32,460
Those two metacharacters are called anchors

173
00:13:32,460 --> 00:13:36,260
because they’re used to tie down
the regular expression

174
00:13:36,260 --> 00:13:40,220
to the beginning and end
of the string they're being matched on

175
00:13:41,480 --> 00:13:47,040
You don’t have to use them, and we’ve got on fine
leaving them out of this example so far

176
00:13:48,660 --> 00:13:52,500
To illustrate why we need them
consider this step

177
00:13:56,700 --> 00:14:00,700
Because we haven’t anchored down the
end of our pattern with a dollar

178
00:14:00,700 --> 00:14:05,840
it will happily match this step
including that bit about Dave at the end

179
00:14:09,600 --> 00:14:13,640
Adding anchors to the beginning and end
of your pattern

180
00:14:13,640 --> 00:14:17,020
prevents this kind of nasty little accident

181
00:14:22,360 --> 00:14:29,600
When Cucumber captures an argument from your step
it’s always a string by default

182
00:14:29,600 --> 00:14:34,500
even if you’ve used a digit character class
in the regular expression

183
00:14:35,440 --> 00:14:41,200
Cucumber is smart enough to convert that string
into the declared type of the method parameter

184
00:14:42,640 --> 00:14:46,340
Cucumber can convert strings into
any of Java’s number types

185
00:14:47,040 --> 00:14:51,520
It can even convert into enum values and dates!

186
00:14:52,280 --> 00:14:56,060
Well, that was a pretty deep dive
into regular expressions!

187
00:14:57,160 --> 00:14:59,440
With what you’ve learned in this lesson

188
00:14:59,440 --> 00:15:04,060
you’ll be able to match any phrase
you see in a Gherkin step without fear

189
00:15:05,100 --> 00:15:08,100
This will help you keep your scenarios readable

190
00:15:08,100 --> 00:15:12,080
and keep your business stakeholders
engaged in the BDD process

191
00:15:15,600 --> 00:15:18,800
We’d love to hear your feedback
about Cucumber School

192
00:15:20,000 --> 00:15:23,540
If you love it, feel free to tweet about us

193
00:15:23,540 --> 00:15:28,040
and mention @cucumberbdd
in your tweet if you like

194
00:15:29,540 --> 00:15:35,500
If there’s anything you’d like us to improve on
or any specific things you want to tell us

195
00:15:35,500 --> 00:15:40,660
please email hello@cucumber.pro
to start the conversation

196
00:15:42,860 --> 00:15:44,860
Captions created by Jayson Smith for Cucumber Ltd.
