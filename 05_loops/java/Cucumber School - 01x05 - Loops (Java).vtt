WEBVTT

1
00:00:14.848 --> 00:00:17.152
Welcome back to Cucumber School

2
00:00:17.920 --> 00:00:24.064
Last time we worked on cleaning up the
Shouty features to keep them in sync

with the current status of the project

3
00:00:24.832 --> 00:00:30.464
We stripped the scenarios back to only specify
the behaviour of passing messages between people

4
00:00:31.232 --> 00:00:35.328
We made it clear that the proximity rule
had not yet been implemented

5
00:00:36.864 --> 00:00:43.008
You’ll remember from the
regular expressions lesson 

how important it is to be
expressive in your scenarios

6
00:00:43.264 --> 00:00:44.800
and keep them readable

7
00:00:45.824 --> 00:00:51.968
In this episode we’re going to learn some
new tricks with Gherkin that will give you

8
00:00:52.224 --> 00:00:54.016
even more flexibility about
how you write scenarios

9
00:00:55.552 --> 00:00:58.624
Once again, the Shouty pixies --

10
00:00:58.880 --> 00:01:05.024
Umm... -- I mean the Shouty developers -- have been
hard at work implementing that proximity rule

11
00:01:06.304 --> 00:01:08.352
Let's have a look at how they got on

12
00:01:11.680 --> 00:01:17.824
Right, so those two scenarios we just left as just placeholders:

13
00:01:18.080 --> 00:01:24.224
the one where the listener is within range
and the one where the listener is out of range

14
00:01:24.480 --> 00:01:24.992
have been fleshed out, and are passing

15
00:01:25.760 --> 00:01:27.040
Fantastic!

16
00:01:28.320 --> 00:01:32.160
Let’s review the changes to
the feature file in more detail

17
00:01:34.208 --> 00:01:36.256
We now have four scenarios: 

18
00:01:36.512 --> 00:01:41.888
our original two from the last time we
looked at the code, and the two new ones

19
00:01:42.656 --> 00:01:47.264
With the two new ones fleshed out
we can see that the first scenario we wrote -

20
00:01:47.520 --> 00:01:52.128
the one where the listener hears a message -
is identical to the third one -

21
00:01:52.384 --> 00:01:55.200
the one where the listener is within range

22
00:01:56.480 --> 00:01:59.296
Keeping excess scenarios is wasteful:

23
00:02:00.576 --> 00:02:04.416
they clutter up your feature files,
distracting your readers

24
00:02:05.440 --> 00:02:11.584
When you run your features as tests

excess scenarios make them
take longer to run than necessary

25
00:02:13.376 --> 00:02:19.520
The one where the listener is within range

is a perfectly good way of checking that
the message has been sent correctly

26
00:02:20.544 --> 00:02:22.080
Let's remove the other one

27
00:02:24.640 --> 00:02:29.504
Similarly, we no longer really need
to be testing multiple messages

28
00:02:30.272 --> 00:02:37.696
We used this test to triangulate and
force us to replace the hard-coded message output

29
00:02:37.952 --> 00:02:39.744
with a proper implementation

30
00:02:40.512 --> 00:02:44.096
Now we have a domain model that uses
a variable for the message

31
00:02:44.352 --> 00:02:50.240
there's an insignificant chance of this behaviour
regressing, so we can safely remove the test

32
00:02:51.776 --> 00:02:56.384
So now we’re down to two scenarios
that illustrate this rule about proximity:

33
00:02:57.152 --> 00:02:59.712
the one where the listener is within range

34
00:03:00.224 --> 00:03:03.296
and the one where the listener is out of range

35
00:03:04.064 --> 00:03:11.232
We’re using two different listeners, Lucy,
who’s always within range, and Larry, who’s not

36
00:03:11.744 --> 00:03:14.048
It’s always Sean who’s doing the shouting

37
00:03:14.560 --> 00:03:18.144
We create all three people here, in the background

38
00:03:18.912 --> 00:03:21.728
Notice that we also specify the range here

39
00:03:22.240 --> 00:03:24.800
We could have just hard-coded it within the system
but having it documented here in the scenario

40
00:03:25.056 --> 00:03:31.200
helps to make the behaviour we’ve specified
much easier to understand

41
00:03:31.968 --> 00:03:38.112
A happy side-effect is that,
in order to set the range from our scenario

42
00:03:38.368 --> 00:03:40.160
we’ve had to make it a configurable property
of the system

43
00:03:40.672 --> 00:03:46.816
So if our business stakeholders ever
change their minds about the range

we won’t have to go hunting around in the code
for where we’d hard-coded it

44
00:03:47.072 --> 00:03:51.680
Notice how the steps that create the three people
are very similar

45
00:03:53.472 --> 00:03:59.616
When we see steps like this, Gherkin’s
Given When Then syntax starts to feel a bit clunky

46
00:04:01.408 --> 00:04:04.736
Imagine if we could just write out a table,
like this

47
00:04:18.047 --> 00:04:21.631
Well, we’re in luck. You can!

48
00:04:22.655 --> 00:04:28.799
Gherkin has a special syntax called Data Tables
that allows you to specify tabular data for a step

49
00:04:29.055 --> 00:04:34.431
using pipe characters to mark the
boundary between cells

50
00:04:38.271 --> 00:04:44.415
As you can see, the step definition
implicitly takes a single argument

51
00:04:44.671 --> 00:04:47.743
which as this comment explains is a
cucumber.api.DataTable

52
00:04:48.511 --> 00:04:52.607
This object has a rich API for using
the tabular data

53
00:04:53.375 --> 00:04:58.495
At its most basic, the table is just a
two-dimensional array of arrays

54
00:05:08.479 --> 00:05:11.551
You can also turn the table into a List of Map

55
00:05:11.807 --> 00:05:17.951
where the first row is used for the map keys
and each following row is used for the map values

56
00:05:19.487 --> 00:05:25.631
Now we can easily iterate over these maps
and turn them into instances of Person

57
00:05:36.383 --> 00:05:41.759
With that done, we can delete our
old step definition, which is now unused

58
00:05:47.391 --> 00:05:53.535
Cucumber strips all the white space
surrounding each cell

so we can have a nice neat table in the
Gherkin but still get

59
00:05:53.791 --> 00:05:56.351
clean values in the step definition underneath

60
00:05:59.679 --> 00:06:05.823
Notice we’ve still had to convert the location
from a string to an integer

61
00:06:06.079 --> 00:06:06.847
because Cucumber can’t know that’s the type
of value in our table

62
00:06:07.871 --> 00:06:12.223
If you have a class that has the same
field names as the header row in the tables

63
00:06:12.479 --> 00:06:17.343
you can have Cucumber automatically convert the table into a list of that class

64
00:06:17.855 --> 00:06:23.999
If our Person object had name and location fields

and didn’t take an instance of Network
in its constructor

65
00:06:24.255 --> 00:06:28.607
we could automatically create instances of Person from this table

66
00:06:29.375 --> 00:06:31.679
But things aren’t always that simple

67
00:06:32.703 --> 00:06:38.847
Instead, we’ll define a simple Whereabouts class
to represent the data in the table

68
00:06:40.127 --> 00:06:46.015
We’ve made it an inner class to
the step definition class

as it doesn’t form part of our core domain

69
00:06:46.783 --> 00:06:54.207
Now we can use the asList method on the DataTable
to convert the table into a list of Whereabouts

70
00:06:55.487 --> 00:06:59.583
In fact, you don’t have to explicitly convert
the table to a list

71
00:06:59.839 --> 00:07:05.983
If you declare your table parameter
as a generic list

72
00:07:06.239 --> 00:07:08.543
Cucumber will automatically convert the table
into a list of the generic type for you

73
00:07:09.567 --> 00:07:15.711
Now the way we’ve specified this data is OK,
but it’s quite hard to visualise where

74
00:07:15.967 --> 00:07:17.503
each of the people is stood

75
00:07:18.015 --> 00:07:21.599
It might be better to express it like this instead

76
00:07:22.879 --> 00:07:24.671
Do you like that better?

77
00:07:25.439 --> 00:07:29.535
You do, but you’re worried how
we’ll handle it in our step definition? 

78
00:07:30.559 --> 00:07:34.399
Fear not. Cucumber has you covered

79
00:07:35.935 --> 00:07:41.311
If you annotate the method parameter
with the @Transpose annotation

80
00:07:41.823 --> 00:07:46.687
Cucumber will turn each row into a column
before passing it to the step definition

81
00:07:47.967 --> 00:07:54.111
You can also call the transpose method on
a DataTable to explicitly create

82
00:07:54.367 --> 00:07:55.647
a new transposed DataTable

83
00:08:04.863 --> 00:08:08.959
Data tables are very useful for
setting up data in Given steps

84
00:08:09.215 --> 00:08:12.543
but you can also use them for specifying outcomes

85
00:08:13.823 --> 00:08:18.943
One rule that we’ve been implying but have
never actually explored with an example

86
00:08:19.199 --> 00:08:23.551
is that people remember everything they’ve heard

87
00:08:24.319 --> 00:08:30.463
So far we’ve only specified a single message,
so let’s try writing a scenario where

88
00:08:30.719 --> 00:08:31.999
Sean shouts more than once

89
00:08:36.351 --> 00:08:39.423
See how natural it is to use a Data Table here?

90
00:08:40.703 --> 00:08:46.847
We also haven’t used any column headers in this case,
since the data is all in a single column anyway

91
00:08:48.383 --> 00:08:50.687
So how do we implement this step definition?

92
00:08:51.711 --> 00:08:57.855
Well, the DataTable has
a really handy method called diff!

93
00:08:58.111 --> 00:09:00.159
that we can use to compare two Data Tables

94
00:09:00.671 --> 00:09:06.303
diff! will pass if the tables are the same,
and fail if they’re different

95
00:09:08.351 --> 00:09:14.495
So we need the actual messages that
Lucy’s heard to be stored in an object

96
00:09:14.751 --> 00:09:17.567
that looks like a DataTable,
so we can compare it to the ones we expect

97
00:09:17.823 --> 00:09:23.967
A List of List of String will do,
so we can just iterate over Lucy’s messages

98
00:09:24.223 --> 00:09:26.271
and create a new single-item List for each row

99
00:09:27.039 --> 00:09:33.183
Now we can pass that list to the diff method

on the table of expected messages
passed in from the Gherkin

100
00:09:39.071 --> 00:09:42.911
Oops! It looks like we made a typo in our scenario

101
00:09:43.167 --> 00:09:47.519
We should have included exclamation marks
on the expected messages

102
00:09:48.031 --> 00:09:54.175
Well, at least this gives you a chance to see
the nice diff output from Cucumber

when the tables are different

103
00:09:54.687 --> 00:10:01.855
We see the expected values prefixed with a minus
and the actual values prefixed with a plus

104
00:10:03.135 --> 00:10:07.743
Let’s fix just one of these so you can see how
the diff output changes

105
00:10:09.535 --> 00:10:15.679
The matching bagels! line no longer has a minus
and for the mis-matched row

106
00:10:15.935 --> 00:10:18.751
the actual value still has a minus,
and the expected value has a plus

107
00:10:19.775 --> 00:10:23.359
Let’s fix this last typo,
and we should be green again

108
00:10:25.919 --> 00:10:26.943
Great

109
00:10:28.223 --> 00:10:33.599
When writing scenarios, occasionally we want
to use a really long piece of data

110
00:10:34.367 --> 00:10:40.511
For example, let’s introduce a new rule
about the maximum length of a message

111
00:10:42.815 --> 00:10:45.375
...and add a scenario to illustrate it,

112
00:10:45.887 --> 00:10:49.215
making the string just over
the boundary of the rule

113
00:10:54.335 --> 00:10:59.967
That’s pretty ugly isn’t it!

114
00:11:00.223 --> 00:11:02.271
Still, we’ll press on and get it to green,
then we’ll show you how to clean it up

115
00:11:03.039 --> 00:11:08.159
Our existing step definition handles that
ugly step with the long message just fine

116
00:11:08.671 --> 00:11:12.511
but we need a new step definition for this last outcome step

117
00:11:13.791 --> 00:11:19.167
We’ll iterate over all the people in the scenario
and check they haven’t heard this message

118
00:11:32.479 --> 00:11:35.551
OK, so we have a failing acceptance test

119
00:11:35.807 --> 00:11:38.623
Let’s dive down into our solution
and implement this new rule

120
00:11:39.903 --> 00:11:46.047
It seems like the Network should be
responsible for implementing this rule

121
00:11:46.303 --> 00:11:50.143
so let’s go to its unit tests and add a new
example to specify this extra responsibility

122
00:12:04.479 --> 00:12:08.575
We’ll create a 181-character message like this

123
00:12:09.599 --> 00:12:14.719
place Lucy and Sean in their usual positions
subscribe Lucy on the network

124
00:12:14.975 --> 00:12:19.327
and then assert that Lucy should not hear
the message when it’s broadcast

125
00:12:21.887 --> 00:12:23.423
Let's run that test

126
00:12:24.447 --> 00:12:26.239
Good, it fails

127
00:12:27.007 --> 00:12:29.823
Lucy’s still getting the message at the moment

128
00:12:31.359 --> 00:12:33.407
Now how are we going to implement this?

129
00:12:34.687 --> 00:12:39.039
It looks like we’re already implementing the
proximity rule here in the broadcast method

130
00:12:39.551 --> 00:12:42.879
Let’s add another if statement here
about the message length

131
00:12:44.415 --> 00:12:46.207
Run the unit test again…

132
00:12:46.719 --> 00:12:49.279
and it’s passing. Great

133
00:12:50.559 --> 00:12:54.143
The code here has got
a little bit messy and hard to read

134
00:12:54.911 --> 00:12:57.727
One very basic move we could make to improve it

135
00:12:58.239 --> 00:13:01.567
would be to just extract
a couple of temporary variables

136
00:13:09.759 --> 00:13:10.783
That’s better

137
00:13:11.551 --> 00:13:16.415
This code could be improved even further of course
but at least we haven’t made it any worse

138
00:13:17.183 --> 00:13:19.487
Let’s just run the tests to check

139
00:13:20.255 --> 00:13:22.559
Great - everything’s still green

140
00:13:24.095 --> 00:13:30.239
Now we have everything passing again,
we can tidy up the Gherkin to use

141
00:13:30.495 --> 00:13:33.055
a new piece of syntax we’ve been wanting
to tell you about: a DocString

142
00:13:34.847 --> 00:13:40.479
DocStrings allow you to specify a text argument
for a step that spans over multiple lines

143
00:13:41.247 --> 00:13:43.807
We could change our step to look like this instead

144
00:13:47.135 --> 00:13:49.439
Now the scenario is much more readable

145
00:13:50.463 --> 00:13:52.767
We don’t use DocStrings very often -

146
00:13:53.023 --> 00:13:57.375
having such a lot of data in a test can often
make it quite brittle

147
00:13:57.887 --> 00:14:01.471
But when you do need it
it's useful to know about

148
00:14:11.711 --> 00:14:17.343
You might have noticed that we’ve followed
a pattern when we added behaviour

to the system during this episode

149
00:14:17.855 --> 00:14:23.999
First we expressed the behaviour
we wanted in a Gherkin scenario

150
00:14:24.255 --> 00:14:27.839
wired up the step definitions
then ran Cucumber to watch it fail

151
00:14:28.607 --> 00:14:34.751
Then, we found the first class in our
domain model that needed to change

152
00:14:35.007 --> 00:14:37.055
in order to support that new behaviour

153
00:14:37.567 --> 00:14:40.895
In this case, the Network class

154
00:14:41.407 --> 00:14:46.783
We used a unit test to describe how
we wanted instances of that class to behave

155
00:14:47.295 --> 00:14:50.623
Then we ran the unit test and watched it fail

156
00:14:52.159 --> 00:14:57.279
We focused in and made changes to the class
until its unit tests were passing

157
00:14:58.047 --> 00:15:04.191
When the unit tests were passing

158
00:15:04.447 --> 00:15:05.471
we then made some minor changes to
clean up the code and make it more readable

159
00:15:05.983 --> 00:15:14.175
This is the basic test-driven-development cycle:
red, green, clean

160
00:15:14.943 --> 00:15:20.319
The technical name for this
last clean-up step is refactoring

161
00:15:20.575 --> 00:15:25.695
Refactoring is an ugly name for
an extremely valuable activity: 

162
00:15:26.207 --> 00:15:31.839
improving the design of existing code
without changing its behaviour

163
00:15:32.351 --> 00:15:37.471
You can think about it like

cleaning up and washing the dishes after
you’ve prepared a meal:

164
00:15:37.983 --> 00:15:40.031
basic housekeeping

165
00:15:40.543 --> 00:15:45.919
But imagine the state of your kitchen
if you never made time to do the dishes

166
00:15:47.455 --> 00:15:50.271
Go on, imagine it for a second

167
00:15:51.807 --> 00:15:53.855
Yuck!

168
00:15:54.367 --> 00:15:59.743
Well, that’s how many, many codebase end up

169
00:16:00.767 --> 00:16:06.911
The good thing about taking this course

is that we’re teaching you how
to write solid automated tests

change the system’s behaviour
your tests will tell you

170
00:16:07.167 --> 00:16:13.311
and the good thing about having
solid automated tests

171
00:16:13.567 --> 00:16:18.431
is you can refactor with confidence
knowing that if you accidentally

172
00:16:20.223 --> 00:16:23.807
Once we’re done refactoring, what do we do next?

173
00:16:24.319 --> 00:16:26.879
Run Cucumber, of course!

174
00:16:27.903 --> 00:16:33.023
In this case, our scenario was passing with
a single trip round the inner TDD loop

175
00:16:33.279 --> 00:16:39.423
but sometimes you can spend several hours
working through all the unit tests

176
00:16:39.679 --> 00:16:40.703
you need to get a single scenario to green

177
00:16:41.215 --> 00:16:43.775
Once the acceptance test is passing

178
00:16:44.031 --> 00:16:47.871
we figure out the next
most valuable scenario on our todo list

179
00:16:48.127 --> 00:16:51.199
and start the whole thing all over again!

180
00:16:52.991 --> 00:16:57.343
Together, these two loops make the BDD cycle

181
00:16:57.855 --> 00:17:01.439
The outer loop,
which starts with an acceptance test

182
00:17:01.695 --> 00:17:06.047
keeps us focused on what the business
needs us to do next

183
00:17:06.815 --> 00:17:12.959
The inner loop,
where we continuously test

184
00:17:13.215 --> 00:17:19.103
implement then refactor small units of code,
is where decide how we’ll implement that behaviour

185
00:17:20.383 --> 00:17:23.711
Both of these levels of feedback are important

186
00:17:24.735 --> 00:17:30.111
It’s sometimes said that your acceptance tests
ensure you’re building the right thing

187
00:17:31.135 --> 00:17:36.511
and your unit tests
ensure you’re building the thing right

188
00:17:39.327 --> 00:17:43.679
That’s all for this lesson of Cucumber School
See you next time!

189
00:17:41.000 --> 00:17:43.000 
Captions created by Jayson Smith for Cucumber Ltd.
