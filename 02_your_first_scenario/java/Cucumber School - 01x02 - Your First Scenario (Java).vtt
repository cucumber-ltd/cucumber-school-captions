WEBVTT

1
00:00:14.700 --> 00:00:19.200
Hello, and welcome to the second lesson
here at Cucumber School

2
00:00:19.600 --> 00:00:23.900
Last time we learned how to use
conversations about concrete examples

3
00:00:23.900 --> 00:00:27.648
to explore your problem domain
and decide what to build

4
00:00:28.416 --> 00:00:32.816
In this episode you'll learn how to
describe those examples using the

5
00:00:32.816 --> 00:00:36.864
Gherkin specification language
so that Cucumber can run them

6
00:00:37.376 --> 00:00:42.240
Then, we'll drive out a solution using
a failing Cucumber scenario to guide us

7
00:00:43.008 --> 00:00:45.500
There's going to be a fair amount
of programming in this episode

8
00:00:45.500 --> 00:00:48.640
and some object-oriented design as well

9
00:00:48.896 --> 00:00:52.480
We want this to feel real,
so we'll work on something fun

10
00:00:52.736 --> 00:00:55.040
A social networking application!

11
00:00:55.808 --> 00:01:02.000
Shouty is a social network that allows
people who are physically close to communicate

12
00:01:02.000 --> 00:01:04.500
just like people have always communicated

13
00:01:04.500 --> 00:01:06.200
with their voices

14
00:01:06.600 --> 00:01:08.300
In the real world you can talk to someone

15
00:01:08.300 --> 00:01:09.900
in the same room or across the street

16
00:01:09.900 --> 00:01:13.700
or even a hundred metres
away from you in a park

17
00:01:13.700 --> 00:01:15.520
if you shout

18
00:01:16.032 --> 00:01:17.312
That's Shouty!

19
00:01:17.568 --> 00:01:22.944
What you say in this social network
can only be heard by people who are nearby

20
00:01:24.480 --> 00:01:27.808
Let's start with a very basic example
of Shouty's behaviour

21
00:01:28.064 --> 00:01:31.648
Something we might have discussed
in a Three Amigos meeting

22
00:01:33.440 --> 00:01:37.500
Sean the shouter shouts, 
"Free bagels at Sean's!"

23
00:01:37.500 --> 00:01:39.000
And Lucy the listener

24
00:01:39.000 --> 00:01:44.000
who happens to be stood across the street
from his store 15 metres away, hears him

25
00:01:44.400 --> 00:01:49.056
She walks into Sean's coffee shop
and takes advantage of the offer

26
00:01:50.592 --> 00:01:55.200
We can translate this into a Gherkin scenario
so that Cucumber can run it

27
00:01:56.992 --> 00:01:58.272
Here's how that would look

28
00:02:00.000 --> 00:02:03.400
You can see that there are four
special keywords being used here

29
00:02:03.400 --> 00:02:09.400
Scenario just tells Cucumber we're about
to describe an example that it can execute

30
00:02:09.400 --> 00:02:14.200
Then you see the lines beginning with
Given, When, and Then

31
00:02:15.800 --> 00:02:20.000
Given is the context for the scenario

32
00:02:20.000 --> 00:02:26.100
We're putting the system into a specific state
ready for the scenario to unfold

33
00:02:27.000 --> 00:02:29.400
When is the action

34
00:02:29.400 --> 00:02:36.300
Something that happens to the system that will
cause something else to happen: an outcome

35
00:02:36.300 --> 00:02:39.000
Then is the outcome

36
00:02:39.000 --> 00:02:46.200
It's the behaviour we expect from the system
when this action happens in this context

37
00:02:49.200 --> 00:02:53.200
You'll notice we've omitted from our outcome
anything about Lucy

38
00:02:53.200 --> 00:02:56.200
walking into Sean's store and making a purchase

39
00:02:56.200 --> 00:02:59.000
Remember, Gherkin is supposed to
describe the behaviour of the system

40
00:02:59.000 --> 00:03:02.500
so it would be distracting to have
that detail in our scenario

41
00:03:03.800 --> 00:03:11.900
Each scenario has these three ingredients:
a context, an action, and one or more outcomes

42
00:03:11.900 --> 00:03:18.000
Together, they describe one single aspect
of the behaviour of the system

43
00:03:19.000 --> 00:03:21.500
Now that we've translated our
example into Gherkin

44
00:03:21.500 --> 00:03:23.300
we can automate it

45
00:03:26.336 --> 00:03:29.000
The easiest way to get started
with Cucumber for Java is to

46
00:03:29.000 --> 00:03:31.600
use a template project with a build script

47
00:03:31.600 --> 00:03:33.500
that sets everything up correctly

48
00:03:34.272 --> 00:03:37.088
You can download this template project from GitHub

49
00:03:37.856 --> 00:03:43.232
Open your web browser and go to the
'cucumber-java-skeleton' project on GitHub

50
00:03:44.000 --> 00:03:47.328
If you're comfortable with git,
you can just clone the project

51
00:03:47.840 --> 00:03:49.750
If you're new to git, don't worry

52
00:03:49.750 --> 00:03:51.680
we'll download a zip file instead

53
00:03:52.704 --> 00:03:57.568
Click releases and download the
most recent that file that starts with a v

54
00:03:58.592 --> 00:04:02.176
If you're on Windows
click the zip file to download it

55
00:04:02.944 --> 00:04:07.552
If you're on OSX or Linux,
just copy the link and download it with wget

56
00:04:08.832 --> 00:04:11.800
On Windows, extract the zip file
by double-clicking on it or

57
00:04:11.800 --> 00:04:16.256
if you're on OSX or Linux
extract it with the unzip command

58
00:04:17.280 --> 00:04:19.300
After extracting the zip file

59
00:04:19.300 --> 00:04:21.887
we'll rename the directory to 'shouty'

60
00:04:23.167 --> 00:04:26.751
In your shell, 'cd' into the shouty directory

61
00:04:27.519 --> 00:04:28.700
The template project contains

62
00:04:28.700 --> 00:04:31.400
Maven and Ant build scripts

63
00:04:31.400 --> 00:04:33.500
that makes it easier to get started

64
00:04:33.500 --> 00:04:34.943
with Cucumber for Java

65
00:04:35.711 --> 00:04:37.100
We'll be using Maven

66
00:04:37.100 --> 00:04:39.100
so if you haven't installed that already

67
00:04:39.100 --> 00:04:40.575
now is a good time

68
00:04:41.599 --> 00:04:43.903
Let's take a look at what else is in this project

69
00:04:44.927 --> 00:04:48.350
There is a main directory for our application code

70
00:04:48.350 --> 00:04:51.071
and a test directory for our test code

71
00:04:52.095 --> 00:04:54.655
Let's remove some of the files that come with the project

72
00:04:55.423 --> 00:05:01.000
Remove Belly.java, Stepdefs.java, and Belly.feature

73
00:05:01.500 --> 00:05:03.400
Now we have a bare bones project

74
00:05:04.000 --> 00:05:07.711
We'll be building it from the ground up
so you can see what is going on

75
00:05:09.247 --> 00:05:14.367
Before we open the project in our IDE,
we're going to modify the name of the application

76
00:05:14.623 --> 00:05:16.415
We'll use a text editor for this

77
00:05:16.671 --> 00:05:18.463
I'm using the Atom editor

78
00:05:18.719 --> 00:05:20.255
But you can use anything you like

79
00:05:21.279 --> 00:05:27.935
Open pom.xml and change the 
groupId, artifactId, and name

80
00:05:29.471 --> 00:05:31.263
We're ready to start coding!

81
00:05:32.031 --> 00:05:35.500
We're going to use
IntelliJ IDEA Community Edition

82
00:05:35.500 --> 00:05:38.200
because it has really nice
Cucumber integration built in

83
00:05:38.800 --> 00:05:43.295
If you prefer to use a different IDE
such as Eclipse, that is fine too.

84
00:05:44.063 --> 00:05:48.415
To open the project in IntelliJ
just open the pom.xml file

85
00:05:52.255 --> 00:05:55.583
Let's rename the package
from skeleton to shouty

86
00:05:56.095 --> 00:05:59.423
In IntelliJ you can rename it
via the Refactor menu

87
00:06:01.800 --> 00:06:04.800
The first file we're going to create
is a feature file 

88
00:06:04.800 --> 00:06:07.103
where we will write our first scenario

89
00:06:07.615 --> 00:06:13.247
Create a file called shout.feature
in the shouty directory, under resources

90
00:06:19.647 --> 00:06:23.231
Now that we have a scenario it's time to run it!

91
00:06:23.487 --> 00:06:28.095
Switch back to the command prompt
and run 'mvn clean test'

92
00:06:28.863 --> 00:06:31.300
Maven will now download Cucumber

93
00:06:31.300 --> 00:06:32.700
compile your code

94
00:06:32.700 --> 00:06:35.100
and tell Cucumber to run the feature file

95
00:06:36.000 --> 00:06:37.100
You'll see that Cucumber has

96
00:06:37.100 --> 00:06:38.100
found our feature file

97
00:06:38.100 --> 00:06:39.615
and read it back to us

98
00:06:41.151 --> 00:06:43.455
We can see a summary of the results at the bottom

99
00:06:44.223 --> 00:06:48.831
Three steps, one scenario, all undefined

100
00:06:50.111 --> 00:06:52.927
Let's run the scenario again
from inside IntelliJ

101
00:06:53.695 --> 00:06:57.279
Select the feature file and choose run
from the context menu

102
00:07:00.863 --> 00:07:02.655
This will give you similar output

103
00:07:04.191 --> 00:07:06.000
Undefined means Cucumber doesn't know

104
00:07:06.000 --> 00:07:08.200
what to do for any of the three steps

105
00:07:08.200 --> 00:07:10.335
we wrote in our Gherkin scenario

106
00:07:11.359 --> 00:07:14.943
It needs us to provide some step definitions

107
00:07:15.199 --> 00:07:18.500
Step definitions translate
from the plain language 

108
00:07:18.500 --> 00:07:21.599
you use in Gherkin, into code

109
00:07:22.623 --> 00:07:26.500
When Cucumber runs a step
it looks for a step definition

110
00:07:26.500 --> 00:07:28.767
that matches the text in the step

111
00:07:29.535 --> 00:07:33.887
If it finds one, then it
executes the code in the step definition

112
00:07:34.911 --> 00:07:36.000
If it doesn't find one

113
00:07:36.000 --> 00:07:38.495
well, you've just seen what happens

114
00:07:39.007 --> 00:07:41.800
Cucumber helpfully prints out
some code snippets that we can use

115
00:07:41.800 --> 00:07:44.895
as a basis for new step definitions

116
00:07:45.151 --> 00:07:46.687
Let's copy those

117
00:07:47.455 --> 00:07:49.000
We'll create a new class in the shouty package

118
00:07:49.000 --> 00:07:51.295
where we'll paste those snippets

119
00:07:51.807 --> 00:07:55.135
Make sure you create it under test and not main

120
00:07:56.159 --> 00:07:59.743
Now IntelliJ's complaining that
there are some unknown symbols

121
00:08:00.255 --> 00:08:02.303
We need to add some import statements

122
00:08:02.815 --> 00:08:04.863
Pressing alt-enter will do that for us

123
00:08:06.399 --> 00:08:08.703
Let's return to the scenario and run it again

124
00:08:11.007 --> 00:08:14.591
There is a small bug in IntelliJ's
Cucumber integration

125
00:08:14.847 --> 00:08:18.687
Sometimes it doesn't tell Cucumber
where to find step definitions

126
00:08:19.100 --> 00:08:20.600
This is easy to work around

127
00:08:20.600 --> 00:08:25.150
Just edit the Run configuration
and make sure the Glue field

128
00:08:25.150 --> 00:08:27.391
contains the value of your package

129
00:08:33.279 --> 00:08:35.071
Now run Cucumber again

130
00:08:35.583 --> 00:08:39.167
This time the output is a little different

131
00:08:39.423 --> 00:08:41.300
We now have a pending step

132
00:08:41.300 --> 00:08:43.500
and two skipped ones

133
00:08:43.500 --> 00:08:45.383
This means Cucumber found all our

134
00:08:45.383 --> 00:08:48.383
step definitions and executed the first one

135
00:08:48.639 --> 00:08:50.000
But that first step definition

136
00:08:50.000 --> 00:08:52.000
throws a Pending exception

137
00:08:52.000 --> 00:08:53.500
which causes Cucumber to stop

138
00:08:53.500 --> 00:08:55.100
skip the rest of the steps

139
00:08:55.100 --> 00:08:58.111
and mark the scenario as pending

140
00:08:59.500 --> 00:09:01.695
It's time to work on our solution

141
00:09:01.951 --> 00:09:04.511
At this point we need to do
a little domain modeling

142
00:09:04.767 --> 00:09:08.500
The words in the step
provide us some good hints

143
00:09:08.500 --> 00:09:11.000
about some names that
will appear in our domain model

144
00:09:11.423 --> 00:09:14.000
Our scenario mentions
two people Lucy and Sean

145
00:09:14.000 --> 00:09:17.567
so it looks like we'll need
a couple of person objects at least

146
00:09:18.591 --> 00:09:21.919
Each person will also need to
know their own location

147
00:09:23.711 --> 00:09:26.000
Cucumber is telling us to
write the code we wish we had

148
00:09:26.000 --> 00:09:27.551
Let's do it!

149
00:09:28.575 --> 00:09:30.300
To implement this step we need to create 

150
00:09:30.300 --> 00:09:34.800
a couple of person objects
with a specified distance between them

151
00:09:34.800 --> 00:09:36.511
We could write it like this

152
00:09:37.791 --> 00:09:42.399
Start by renaming the 'arg1' parameter
to something that better reflects its meaning

153
00:09:43.167 --> 00:09:44.959
We'll call it distance

154
00:09:46.239 --> 00:09:48.000
To keep things simple 
we're going to assume

155
00:09:48.000 --> 00:09:50.335
all people are situated on a line

156
00:09:51.103 --> 00:09:53.663
A one-dimensional coordinate system

157
00:09:54.431 --> 00:09:57.503
We can always introduce proper geo locations later

158
00:09:57.759 --> 00:09:59.500
We'll place Sean in the center

159
00:09:59.500 --> 00:10:02.000
and Lucy 15 metres away from Sean

160
00:10:06.975 --> 00:10:10.559
Notice that the number 15
does not appear anywhere in our code

161
00:10:10.815 --> 00:10:16.447
The value 15 is automatically passed
from the Gherkin step into the step definition

162
00:10:16.703 --> 00:10:18.000
If you're curious

163
00:10:18.000 --> 00:10:22.335
that's the '\d' in the
pattern of the step definition

164
00:10:23.103 --> 00:10:26.943
We'll explain regular expressions
in detail in a future lesson

165
00:10:29.800 --> 00:10:32.319
Before we can run the code we just wrote

166
00:10:32.575 --> 00:10:34.879
we need to fix the compilation errors

167
00:10:35.500 --> 00:10:38.207
Let's create a class called person

168
00:10:43.327 --> 00:10:45.631
Then we'll add a setter for the location

169
00:10:56.639 --> 00:10:58.500
When we run the scenario again

170
00:10:58.500 --> 00:11:00.735
the first step is green!

171
00:11:02.271 --> 00:11:05.000
We'll follow the same flow
to make the remaining two steps pass

172
00:11:05.000 --> 00:11:09.100
do a little bit of domain modeling,
write the code we wish we had,

173
00:11:09.100 --> 00:11:12.255
make it compile, and run the scenario

174
00:11:14.303 --> 00:11:18.399
In the second step definition,
we want to tell Sean to shout something

175
00:11:28.127 --> 00:11:33.750
In order to send instructions to Sean,
we need to store him in an instance variable

176
00:11:33.750 --> 00:11:38.623
so that he'll be accessible
from all of our definitions, like this

177
00:11:41.951 --> 00:11:45.023
Our Person class needs a 'shout' method

178
00:11:45.535 --> 00:11:46.559
Let's add it!

179
00:11:48.607 --> 00:11:50.655
Don't worry about the implementation yet

180
00:11:50.911 --> 00:11:55.775
The important thing right now is to
discover the shape of our domain model

181
00:11:57.055 --> 00:12:01.300
The last step definition is where
we implement the check or assertion.

182
00:12:01.300 --> 00:12:03.500
We'll verify that what Lucy has heard

183
00:12:03.500 --> 00:12:06.783
is exactly the same as what Sean shouted

184
00:12:09.087 --> 00:12:11.647
Once again we're going to
write the code we wish we had

185
00:12:24.700 --> 00:12:29.200
So we need a way to ask Lucy
what messages she's heard

186
00:12:29.200 --> 00:12:33.407
and we also need to know
what it was that Sean shouted

187
00:12:34.000 --> 00:12:39.500
We can record what Sean shouts
by storing it an instance variable

188
00:12:39.500 --> 00:12:41.855
as the When step runs

189
00:12:42.367 --> 00:12:45.000
This is a common pattern to use
in Cucumber step definitions

190
00:12:45.000 --> 00:12:48.000
when you don't want to repeat
the same test data in different 

191
00:12:48.000 --> 00:12:49.800
parts of a scenario

192
00:12:51.071 --> 00:12:54.143
Now we can use that value in the assertion check

193
00:12:55.423 --> 00:12:59.775
We also need to add a 'messages heard'
method to our Person class

194
00:13:00.031 --> 00:13:01.311
Let's do that now

195
00:13:05.663 --> 00:13:07.455
This is great!

196
00:13:07.967 --> 00:13:14.111
Whenever we do BDD, getting to our
first failing test is a milestone

197
00:13:14.367 --> 00:13:18.719
Seeing the test fail, proves that it is
capable of detecting errors in our code

198
00:13:18.975 --> 00:13:24.351
Never trust an automated test that
you haven't seen fail!

199
00:13:25.887 --> 00:13:29.300
Now all we have to do is write
the code to make it pass

200
00:13:29.300 --> 00:13:31.200
That's the easy bit!

201
00:13:32.543 --> 00:13:35.359
In this case we're going to cheat

202
00:13:36.500 --> 00:13:39.711
We have a one line fix that will
make the scenario pass

203
00:13:40.479 --> 00:13:42.527
It's not a particularly

204
00:13:42.783 --> 00:13:45.087
future-proof implementation

205
00:13:46.367 --> 00:13:47.903
Can you guess what it is?

206
00:13:51.231 --> 00:13:52.255
I'll show you

207
00:13:54.047 --> 00:13:57.119
Hmm, there. I told you it
wasn't very future-proof!

208
00:13:57.887 --> 00:14:03.007
Still, the fact that such a poor
implementation can pass our tests

209
00:14:03.007 --> 00:14:05.823
shows us that we need to work on our tests

210
00:14:06.335 --> 00:14:08.500
A more comprehensive set of scenarios would

211
00:14:08.500 --> 00:14:11.199
force us to write a better implementation

212
00:14:12.735 --> 00:14:15.551
This is the essence of
behaviour-driven development

213
00:14:15.807 --> 00:14:19.135
Examples of behaviour drive the development

214
00:14:21.695 --> 00:14:25.300
So we know we need more scenarios
and a better solution

215
00:14:25.300 --> 00:14:27.000
Instead of writing a note on our to-do list

216
00:14:27.000 --> 00:14:29.631
let's write another failing scenario

217
00:14:32.447 --> 00:14:35.000
Now when we come back to this code
we can just run the tests

218
00:14:35.000 --> 00:14:38.335
and Cucumber will remind us
what we need to do next

219
00:14:38.600 --> 00:14:40.127
We're done for the day!

220
00:14:40.400 --> 00:14:42.431
Go make yourself a cup of tea

221
00:14:43.500 --> 00:14:45.500
Captions created by Jayson Smith for Cucumber Ltd.
