WEBVTT

1
00:00:14.700 --> 00:00:19.200
Hello, and welcome to the second lesson
here at Cucumber School

2
00:00:19.600 --> 00:00:23.900
Last time we learned how to use
conversations about concrete examples

3
00:00:23.900 --> 00:00:27.648
to explore your problem domain
and decide what to build

4
00:00:28.416 --> 00:00:32.816
In this episode you'll learn how to
describe those examples using the

5
00:00:32.816 --> 00:00:36.864
Gherkin specification language
so that Cucumber can run them

6
00:00:37.376 --> 00:00:42.240
Then, we'll drive out a solution using
a failing Cucumber scenario to guide us

7
00:00:43.008 --> 00:00:45.500
There's going to be a fair amount
of programming in this episode

7
00:00:45.500 --> 00:00:48.640
and some object-oriented design as well

8
00:00:48.896 --> 00:00:52.480
We want this to feel real,
so we'll work on something fun

9
00:00:52.736 --> 00:00:55.040
A social networking application!

10
00:00:55.808 --> 00:01:02.000
Shouty is a social network that allows
people who are physically close to communicate

11
00:01:02.000 --> 00:01:04.500
just like people have always communicated

11
00:01:04.500 --> 00:01:06.200
with their voices

11
00:01:06.600 --> 00:01:08.300
In the real world you can talk to someone

11
00:01:08.300 --> 00:01:09.900
in the same room or across the street

12
00:01:09.900 --> 00:01:13.700
or even a hundred metres
away from you in a park

13
00:01:13.700 --> 00:01:15.520
if you shout

14
00:01:16.032 --> 00:01:17.312
That's Shouty!

15
00:01:17.568 --> 00:01:22.944
What you say in this social network
can only be heard by people who are nearby

16
00:01:24.480 --> 00:01:27.808
Let's start with a very basic example
of Shouty's behaviour

17
00:01:28.064 --> 00:01:31.648
Something we might have discussed
in a Three Amigos meeting

18
00:01:33.440 --> 00:01:37.500
Sean the shouter shouts, 
"Free bagels at Sean's!"

18
00:01:37.500 --> 00:01:39.000
And Lucy the listener

19
00:01:39.000 --> 00:01:44.000
who happens to be stood across the street
from his store 15 metres away, hears him

20
00:01:44.400 --> 00:01:49.056
She walks into Sean's coffee shop
and takes advantage of the offer

21
00:01:50.592 --> 00:01:55.200
We can translate this into a Gherkin scenario
so that Cucumber can run it

22
00:01:56.992 --> 00:01:58.272
Here's how that would look

23
00:01:59.600 --> 00:02:03.100
You can see that there are four
special keywords being used here

24
00:02:03.100 --> 00:02:08.256
Scenario just tells Cucumber we're about
to describe an example that it can execute

25
00:02:09.280 --> 00:02:13.888
Then you see the lines beginning with
Given, When, and Then

26
00:02:14.912 --> 00:02:19.008
Given is the context for the scenario

28
00:02:19.264 --> 00:02:25.152
We're putting the system into a specific state
ready for the scenario to unfold

29
00:02:26.176 --> 00:02:28.224
When is the action

30
00:02:28.992 --> 00:02:34.880
Something that happens to the system that will
cause something else to happen: an outcome

31
00:02:36.416 --> 00:02:38.464
Then is the outcome

32
00:02:38.976 --> 00:02:46.000
It's the behaviour we expect from the system
when this action happens in this context

33
00:02:49.200 --> 00:02:53.200
You'll notice we've omitted from our outcome
anything about Lucy

34
00:02:53.200 --> 00:02:56.200
walking into Sean's store and making a purchase

35
00:02:56.200 --> 00:02:59.000
Remember Gherkin is supposed to
describe the behaviour of the system

35
00:02:59.000 --> 00:03:01.600
so it would be distracting to have
that detail in our scenario

36
00:03:02.600 --> 00:03:10.208
Each scenario has these three ingredients:
a context, an action, and one or more outcomes

38
00:03:10.720 --> 00:03:16.864
Together, they describe one single aspect
of the behaviour of the system

39
00:03:17.600 --> 00:03:21.000
Now that we've translated our
example into Gherkin

40
00:03:21.000 --> 00:03:22.752
we can automate it

41
00:03:26.336 --> 00:03:30.000
The easiest way to get started
with Cucumber for Java is to

41
00:03:30.000 --> 00:03:32.480
use a template project with a build script

42
00:03:32.736 --> 00:03:33.504
that sets everything up correctly

43
00:03:34.272 --> 00:03:37.088
You can download this template project from GitHub

44
00:03:37.856 --> 00:03:43.232
Open your web browser and go to the 'cucumber-java-skeleton' project on github

45
00:03:44.000 --> 00:03:47.328
If you're comfortable with git, you can just clone the project

46
00:03:47.840 --> 00:03:49.632
If you need to git don't worry

47
00:03:49.888 --> 00:03:51.680
we'll downloaded zip file instead

48
00:03:52.704 --> 00:03:57.568
Click releases and download the most recent that file that starts with a v

49
00:03:58.592 --> 00:04:02.176
If you're on Windows click the zip file to download it

50
00:04:02.944 --> 00:04:07.552
If you're on OSX or Linux, just copy the link and download it with wget

51
00:04:08.832 --> 00:04:14.976
On Windows, extract the zip file by double-clicking on it or, if you're on OSX or Linux

52
00:04:15.232 --> 00:04:16.256
Extract it with the unzip command

53
00:04:17.280 --> 00:04:21.887
After extracting the zip file, we'll rename the directory to 'shouty'

54
00:04:23.167 --> 00:04:26.751
In your shell, 'cd' into the shouty directory

55
00:04:27.519 --> 00:04:33.663
The template project contains Maven and Ant build scripts that makes it easier to get started with

56
00:04:33.919 --> 00:04:34.943
Cucumber for Java

57
00:04:35.711 --> 00:04:40.575
We'll be using Maven so if you haven't installed that already, now's a good time

58
00:04:41.599 --> 00:04:43.903
Let's take a look at what else is in this project

59
00:04:44.927 --> 00:04:48.255
There is a 'main' directory for application code

60
00:04:48.511 --> 00:04:51.071
And a 'test' directory for test code

61
00:04:52.095 --> 00:04:54.655
Let's remove some of the files that come with the project

62
00:04:55.423 --> 00:05:01.055
Remove 'Belly.java', 'Stepdefs.java', and 'Belly.feature'

63
00:05:01.567 --> 00:05:03.871
Now we have a bare bones project

64
00:05:04.127 --> 00:05:07.711
We'll be building it from the ground up so you can see what is going on

65
00:05:09.247 --> 00:05:14.367
Before we open the project in our IDE, we're going to modify the name of the application

66
00:05:14.623 --> 00:05:16.415
We'll use a text editor for this

67
00:05:16.671 --> 00:05:18.463
I'm using the atom editor

68
00:05:18.719 --> 00:05:20.255
But you can use anything you like

69
00:05:21.279 --> 00:05:27.935
Open pom.xml and change the 
groupId, artifactId, and name

72
00:05:29.471 --> 00:05:31.263
We're ready to start coding

73
00:05:32.031 --> 00:05:38.175
We're going to use IntelliJ IDEA Community Edition because it has really nice cucumber integration built in

74
00:05:38.943 --> 00:05:43.295
If you prefer to use a different IDE
such as Eclipse, that is fine too.

75
00:05:44.063 --> 00:05:48.415
To open the project in IntelliJ
just open the pom.xml file

76
00:05:52.255 --> 00:05:55.583
Let's rename the package
from skeleton to shouty

77
00:05:56.095 --> 00:05:59.423
In IntelliJ you can rename it
via the Refactor menu

78
00:06:01.983 --> 00:06:05.000
The first file we're going to create
is a feature file 

78
00:06:05.000 --> 00:06:07.103
where we will write our first scenario

79
00:06:07.615 --> 00:06:13.247
Create a file called shout.feature
in the shouty directory, under resources

80
00:06:19.647 --> 00:06:23.231
Now that we have a scenario it's time to run it!

81
00:06:23.487 --> 00:06:28.095
Switch back to the command prompt
and run 'mvn clean test'

82
00:06:28.863 --> 00:06:31.167
Maven will now download Cucumber

83
00:06:31.423 --> 00:06:35.007
Compile your code and tell Cucumber
to run the feature file

84
00:06:36.031 --> 00:06:38.615
You'll see that Cucumber has found
our feature file

84
00:06:38.615 --> 00:06:39.615
and read it back to us

85
00:06:41.151 --> 00:06:43.455
We can see a summary of the results
at the bottom

86
00:06:44.223 --> 00:06:48.831
Three steps, one scenario, all undefined

87
00:06:50.111 --> 00:06:52.927
Let's run the scenario again
from inside IntelliJ

88
00:06:53.695 --> 00:06:57.279
Select the feature file and choose run
from the context menu

89
00:07:00.863 --> 00:07:02.655
This will give you similar output

90
00:07:04.191 --> 00:07:08.200
Undefined means Cucumber doesn't know
what to do for any of the three steps

90
00:07:08.200 --> 00:07:10.335
we wrote in our Gherkin scenario

91
00:07:11.359 --> 00:07:14.943
It needs us to provide some step definitions

92
00:07:15.199 --> 00:07:18.500
Step definitions translate
from the plain language 

93
00:07:18.500 --> 00:07:21.599
you use in Gherkin, into code

94
00:07:22.623 --> 00:07:26.500
When Cucumber runs a step
it looks for a step definition

67
00:07:26.500 --> 00:07:28.767
that matches the text in the step

95
00:07:29.535 --> 00:07:33.887
If it finds one, then it
executes the code in the step definition

96
00:07:34.911 --> 00:07:36.000
If it doesn't find one

96
00:07:36.000 --> 00:07:38.495
well, you've just seen what happens

97
00:07:39.007 --> 00:07:41.800
Cucumber helpfully prints out
some code snippets that we can use

71
00:07:41.800 --> 00:07:44.895
as a basis for new step definitions

98
00:07:45.151 --> 00:07:46.687
Let's copy those

99
00:07:47.455 --> 00:07:51.295
We'll creates a new class in the shouty package where we'll paste those snippets

100
00:07:51.807 --> 00:07:55.135
Make sure you create it under test and not main

101
00:07:56.159 --> 00:07:59.743
Now IntelliJ's complaining that there are some unknown symbols

102
00:08:00.255 --> 00:08:02.303
We need to add some import statements

103
00:08:02.815 --> 00:08:04.863
Pressing alt-enter will do that for us

104
00:08:06.399 --> 00:08:08.703
Let's return to the scenario and run it again

105
00:08:11.007 --> 00:08:14.591
There is a small bug in IntelliJ's
Cucumber integration

106
00:08:14.847 --> 00:08:18.687
Sometimes it doesn't tell Cucumber
where to find step definitions

107
00:08:19.100 --> 00:08:20.600
This is easy to work around

107
00:08:20.600 --> 00:08:25.150
Just edit the Run configuration
and make sure the Glue field

108
00:08:25.150 --> 00:08:27.391
contains the value of your package

109
00:08:33.279 --> 00:08:35.071
Now run Cucumber again

110
00:08:35.583 --> 00:08:39.167
This time the output is a little different

111
00:08:39.423 --> 00:08:41.300
We now have a pending step

111
00:08:41.300 --> 00:08:43.500
and two skipped ones

112
00:08:43.500 --> 00:08:45.383
This means Cucumber found all our

112
00:08:45.383 --> 00:08:48.383
step definitions and executed the first one

113
00:08:48.639 --> 00:08:50.000
But that first step definition

113
00:08:50.000 --> 00:08:52.000
throws a Pending exception

114
00:08:52.000 --> 00:08:53.500
which causes Cucumber to stop

114
00:08:53.500 --> 00:08:55.100
skip the rest of the steps

81
00:08:55.100 --> 00:08:58.111
and mark the scenario as pending

115
00:08:59.647 --> 00:09:01.695
It's time to work on our solution

116
00:09:01.951 --> 00:09:04.511
At this point we need to do
a little domain modeling

117
00:09:04.767 --> 00:09:10.911
The words in the step
provide us some good hints

84
00:06:58.000 --> 00:07:01.400
about some names that
will appear in our domain model

118
00:09:11.423 --> 00:09:14.000
Our scenario mentions
two people Lucy and Sean

85
00:09:14.000 --> 00:09:17.567
so it looks like we'll need
a couple of person objects at least

119
00:09:18.591 --> 00:09:21.919
Each person will also need to
know their own location

120
00:09:23.711 --> 00:09:24.500
Cucumber is telling us to
write the code we wish we had

120
00:09:24.500 --> 00:09:27.551
Let's do it!

121
00:09:28.575 --> 00:09:34.719
To implement this step we need to create 

a couple of person objects
with a specified distance between them

122
00:09:34.975 --> 00:09:36.511
We could write it like this

123
00:09:37.791 --> 00:09:42.399
Start by renaming the 'arg1' parameter
to something about the reflects its meaning

124
00:09:43.167 --> 00:09:44.959
We'll call it distance

125
00:09:46.239 --> 00:09:50.335
To keep things simple 
we're going to assume

all people are situated on a line

126
00:09:51.103 --> 00:09:53.663
A one-dimensional coordinate system

127
00:09:54.431 --> 00:09:57.503
We can always introduce proper geo locations later

128
00:09:57.759 --> 00:10:02.111
We'll place Sean in the center

and Lucy 15 metres away from Sean

129
00:10:06.975 --> 00:10:10.559
Notice that the number 15
does not appear anywhere in our code

130
00:10:10.815 --> 00:10:16.447
The value 15 is automatically passed
from the Gherkin step into the step definition

131
00:10:16.703 --> 00:10:22.335
If you're curious

that's the '\d' in the
pattern of the step definition

132
00:10:23.103 --> 00:10:26.943
We'll explain regular expressions
in detail in a future lesson

133
00:10:30.015 --> 00:10:32.319
Before we can run the code we just wrote

134
00:10:32.575 --> 00:10:34.879
we need to fix the compilation errors

135
00:10:35.647 --> 00:10:38.207
Let's create a class called person

136
00:10:43.327 --> 00:10:45.631
Then we'll add a setter
for the location

137
00:10:56.639 --> 00:10:58.500
When we run the scenario again

138
00:10:58.500 --> 00:11:00.735
the first step is green!

139
00:11:02.271 --> 00:11:07.391
We'll follow the same flow
to make the remaining two steps pass

do a little bit of domain modeling,
write the code we wish we had,

140
00:11:07.647 --> 00:11:12.255
make it compile, and run the scenario

141
00:11:14.303 --> 00:11:18.399
In the second step definition,
we want to tell Sean to shout something

142
00:11:28.127 --> 00:11:33.750
In order to send instructions to Sean,
we need to store him in an instance variable

143
00:11:33.750 --> 00:11:38.623
so that he'll be accessible
from all of our definitions, like this

144
00:11:41.951 --> 00:11:45.023
Our Person class needs a 'shout' method

145
00:11:45.535 --> 00:11:46.559
Let's add it!

146
00:11:48.607 --> 00:11:50.655
Don't worry about the implementation yet

147
00:11:50.911 --> 00:11:55.775
The important thing right now is to
discover the shape of our domain model

148
00:11:57.055 --> 00:12:03.199
The last step definition is where
we implement the check or assertion.

122
00:12:03.455 --> 00:12:06.783
We'll verify that what Lucy has heard

123
00:12:03.455 --> 00:12:06.783
is exactly the same as what Sean shouted

150
00:12:09.087 --> 00:12:11.647
Once again we're going to
write the code we wish we had

151
00:12:24.959 --> 00:12:29.200
So we need a way to ask Lucy
what messages she's heard

152
00:12:29.200 --> 00:12:33.407
and we also need to know
what it was that Sean shouted

153
00:12:34.175 --> 00:12:39.500
We can record what Sean shouts
by storing it an instance variable

154
00:12:39.500 --> 00:12:41.855
as the When step runs

155
00:12:42.367 --> 00:12:45.000
This is a common pattern to use
in Cucumber step definitions

155
00:12:45.000 --> 00:12:48.000
when you don't want to repeat
the same test data in different 

156
00:12:48.000 --> 00:12:49.791
parts of a scenario

157
00:12:51.071 --> 00:12:54.143
Now we can use that value in the assertion check

158
00:12:55.423 --> 00:12:59.775
We also need to add a 'messages heard'
method to our Person class

159
00:13:00.031 --> 00:13:01.311
Let's do that now

160
00:13:05.663 --> 00:13:07.455
This is great!

161
00:13:07.967 --> 00:13:14.111
Whenever we do BDD, getting to our
first failing test is a milestone

162
00:13:14.367 --> 00:13:18.719
Seeing the test fail, proves that it is
capable of detecting errors in our code

163
00:13:18.975 --> 00:13:24.351
Never trust an automated test that
you haven't seen fail!

164
00:13:25.887 --> 00:13:29.215
Now all we have to do is write
the code to make it pass

165
00:13:29.471 --> 00:13:31.007
That's the easy bit!

166
00:13:32.543 --> 00:13:35.359
In this case we're going to cheat

167
00:13:36.639 --> 00:13:39.711
We have a one line fix that will
make the scenario pass

168
00:13:40.479 --> 00:13:42.527
It's not a particularly

169
00:13:42.783 --> 00:13:45.087
future-proof implementation

170
00:13:46.367 --> 00:13:47.903
Can you guess what it is?

171
00:13:51.231 --> 00:13:52.255
I'll show you

172
00:13:54.047 --> 00:13:57.119
Hmm, there. I told you it
wasn't very future-proof!

173
00:13:57.887 --> 00:14:03.007
Still, the fact that such a poor
implementation can pass our tests

175
00:14:03.007 --> 00:14:05.823
shows us that we need to work on our tests

176
00:14:06.335 --> 00:14:11.199
A more comprehensive set of scenarios would

force us to write a better implementation

177
00:14:12.735 --> 00:14:15.551
This is the essence of
behaviour-driven development

178
00:14:15.807 --> 00:14:19.135
Examples of behaviour drive the development

179
00:14:21.695 --> 00:14:27.839
So we know we need more scenarios
and a better solution

180
00:14:28.095 --> 00:14:29.631
Instead of writing a note on our to-do list

let's write another failing scenario

181
00:14:32.447 --> 00:14:38.335
Now when we come back to this code
we can just run the tests

and Cucumber will remind us
what we need to do next

182
00:14:38.847 --> 00:14:40.127
We're done for the day!

183
00:14:40.639 --> 00:14:42.431
Go make yourself a cup of tea

164
00:14:44.000 --> 00:14:16.000
Captions created by Jayson Smith for Cucumber Ltd.