WEBVTT

1
00:00:14.700 --> 00:00:19.200
Hello, and welcome to the second lesson
here at Cucumber School

2
00:00:19.712 --> 00:00:23.900
Last time we learned how to use
conversations about concrete examples

3
00:00:23.900 --> 00:00:27.648
to explore your problem domain
and decide what to build

4
00:00:28.416 --> 00:00:32.816
In this episode you'll learn how to
describe those examples using the

5
00:00:32.816 --> 00:00:36.864
Gherkin specification language
so that Cucumber can run them

6
00:00:37.376 --> 00:00:42.240
Then, we'll drive out a solution using
a failing Cucumber scenario to guide us

7
00:00:43.008 --> 00:00:45.500
There's going to be a fair amount
of programming in this episode

7
00:00:45.500 --> 00:00:48.640
and some object-oriented design as well

8
00:00:48.896 --> 00:00:52.480
We want this to feel real,
so we'll work on something fun

9
00:00:52.736 --> 00:00:55.040
A social networking application!

10
00:00:55.808 --> 00:01:02.000
Shouty is a social network that allows
people who are physically close to communicate

11
00:01:02.000 --> 00:01:04.500
just like people have always communicated

11
00:01:04.500 --> 00:01:06.200
with their voices

11
00:01:06.600 --> 00:01:08.300
In the real world you can talk to someone

11
00:01:08.300 --> 00:01:09.900
in the same room or across the street

12
00:01:09.900 --> 00:01:13.700
or even a hundred metres
away from you in a park

13
00:01:13.700 --> 00:01:15.520
if you shout

14
00:01:16.032 --> 00:01:17.312
That's Shouty!

15
00:01:17.568 --> 00:01:22.944
What you say in this social network
can only be heard by people who are nearby

16
00:01:24.480 --> 00:01:27.808
Let's start with a very basic example
of Shouty's behaviour

17
00:01:28.064 --> 00:01:31.648
Something we might have discussed
in a Three Amigos meeting

18
00:01:33.440 --> 00:01:37.500
Sean the shouter shouts, 
"Free bagels at Sean's!"

18
00:01:37.500 --> 00:01:39.000
And Lucy the listener

19
00:01:39.000 --> 00:01:44.000
who happens to be stood across the street
from his store 15 metres away, hears him

20
00:01:44.400 --> 00:01:49.056
She walks into Sean's coffee shop
and takes advantage of the offer

21
00:01:50.592 --> 00:01:55.200
We can translate this into a Gherkin scenario
so that Cucumber can run it

22
00:01:56.992 --> 00:01:58.272
Here's how that would look

23
00:01:59.552 --> 00:02:02.624
You can see that there are four
special keywords being used here

24
00:02:02.880 --> 00:02:08.256
Scenario just tells Cucumber we're about
to describe an example that it can execute

25
00:02:09.280 --> 00:02:13.888
Then you see the lines beginning with
Given, When, and Then

26
00:02:14.912 --> 00:02:19.008
Given is the context for the scenario

28
00:02:19.264 --> 00:02:25.152
We're putting the system into a specific state
ready for the scenario to unfold

29
00:02:26.176 --> 00:02:28.224
When is the action

30
00:02:28.992 --> 00:02:34.880
Something that happens to the system that will
cause something else to happen: an outcome

31
00:02:36.416 --> 00:02:38.464
Then is the outcome

32
00:02:38.976 --> 00:02:45.120
It's the behaviour we expect from the system
when this action happens in this context

33
00:02:48.500 --> 00:02:51.950
You'll notice we've omitted from our outcome
anything about Lucy

34
00:02:51.950 --> 00:02:54.848
walking into Sean's store and making a purchase

35
00:02:55.000 --> 00:02:57.800
Remember Gherkin is supposed to
describe the behaviour of the system

35
00:02:57.800 --> 00:03:01.600
so it would be distracting to have
that detail in our scenario

36
00:03:02.600 --> 00:03:10.208
Each scenario has these three ingredients:
a context, an action, and one or more outcomes

38
00:03:10.720 --> 00:03:16.864
Together, they describe one single aspect
of the behaviour of the system

39
00:03:17.600 --> 00:03:21.000
Now that we've translated our
example into Gherkin

40
00:03:21.000 --> 00:03:22.752
we can automate it

41
00:03:24.544 --> 00:03:26.000
Before we get started

41
00:03:26.000 --> 00:03:30.688
make sure you have a modern version
of Ruby installed and the Bundler gem

42
00:03:31.456 --> 00:03:33.504
Open a command prompt and type

43
00:03:37.500 --> 00:03:40.500
If you see an error message
when you run these commands

43
00:03:40.500 --> 00:03:42.976
you'll need to fix your Ruby installation

44
00:03:44.150 --> 00:03:48.096
Go back to the command prompt
and create a new directory for our project

45
00:03:50.656 --> 00:03:55.520
Use 'cd' to go into that directory
and open it up in your editor

46
00:03:57.312 --> 00:04:03.456
First, we'll create a gemfile that
describes the Ruby gems we need for our project

47
00:04:03.712 --> 00:04:09.088
We'll add Cucumber and RSpec expectations

48
00:04:10.880 --> 00:04:13.800
Now go back to the command line
and run 'bundle install' 

48
00:04:13.800 --> 00:04:16.000
to install these gems

49
00:04:17.200 --> 00:04:18.800
Now we're ready!

49
00:04:19.000 --> 00:04:22.500
If we run Cucumber at this point
you'll see it's telling us

50
00:04:22.500 --> 00:04:24.600
to create a features directory

51
00:04:25.000 --> 00:04:28.543
That's the conventional place to
store your Gherkin specifications

52
00:04:28.799 --> 00:04:30.079
Let's create one

53
00:04:32.639 --> 00:04:35.455
Now we're ready to create our
first feature file

54
00:04:35.967 --> 00:04:39.551
Call the file 'shouty.feature'

55
00:04:41.599 --> 00:04:45.000
All feature files start with the keyword 'feature'

56
00:04:45.000 --> 00:04:46.975
followed by a name

57
00:04:47.231 --> 00:04:50.559
It's a good convention to give it
a name that matches the file name

58
00:04:52.095 --> 00:04:54.399
Now let's write out our first scenario

59
00:05:08.479 --> 00:05:12.319
Switch back to the command prompt
and run 'cucumber'

60
00:05:13.200 --> 00:05:17.439
You'll see Cucumber has found
a feature file and read it back to us

61
00:05:17.500 --> 00:05:20.000
We can see a summary of
the results at the bottom:

62
00:05:20.100 --> 00:05:25.119
three steps, one scenario, all undefined

63
00:05:25.631 --> 00:05:28.000
Undefined means Cucumber
doesn't know what to do

63
00:05:28.000 --> 00:05:31.775
for any of the three steps
we wrote in our Gherkin scenario

64
00:05:33.055 --> 00:05:36.895
It needs us to provide it with
some step definitions

65
00:05:37.000 --> 00:05:40.100
Step definitions translate
from the plain language 

66
00:05:40.100 --> 00:05:43.295
you use in Gherkin, into code

67
00:05:44.319 --> 00:05:48.200
When Cucumber runs a step
it looks for a step definition

67
00:05:48.200 --> 00:05:50.600
that matches the text in the step

68
00:05:51.200 --> 00:05:55.839
If it finds one, then it
executes the code in the step definition

69
00:05:56.095 --> 00:05:58.000
If it doesn't find one,

70
00:05:58.000 --> 00:06:00.191
well you've just seen what happens

71
00:06:00.703 --> 00:06:04.000
Cucumber helpfully prints out
some code snippets that we can use

71
00:06:04.000 --> 00:06:06.847
as a basis for new step definitions

72
00:06:07.000 --> 00:06:08.639
Let's copy these

73
00:06:09.919 --> 00:06:16.063
We'll paste them into a Ruby file
under a new directory called 'step_definitions'

74
00:06:16.575 --> 00:06:18.623
underneath the features directory

75
00:06:19.135 --> 00:06:22.463
I'll just call it 'steps.rb'

76
00:06:23.500 --> 00:06:25.400
Now run 'cucumber' again

77
00:06:25.600 --> 00:06:29.375
This time the output is a little different

78
00:06:29.887 --> 00:06:33.800
We now have a pending step
and two skipped ones

79
00:06:34.000 --> 00:06:38.847
This means Cucumber found all our
step definitions and executed the first one

80
00:06:39.103 --> 00:06:42.200
But that first step definition
throws a Pending exception

80
00:06:42.200 --> 00:06:45.400
which causes Cucumber to stop,
skip the rest of the steps

81
00:06:45.400 --> 00:06:48.575
and mark the scenario as pending

82
00:06:49.855 --> 00:06:51.800
It's time to work on our solution

83
00:06:52.000 --> 00:06:55.000
At this point we need to do
a little domain modeling

84
00:06:55.000 --> 00:06:58.000
The words in the step
provide us some good hints

84
00:06:58.000 --> 00:07:01.400
about some names that
will appear in our domain model

85
00:07:01.400 --> 00:07:04.800
Our scenario mentions
two people Lucy and Sean

85
00:07:04.800 --> 00:07:08.600
so it looks like we'll need
a couple of person objects at least

87
00:07:08.600 --> 00:07:12.383
Each person will also need to
know their own location

88
00:07:13.700 --> 00:07:16.600
Cucumber is telling us to
write the code we wish we had

88
00:07:16.600 --> 00:07:18.000
Let's do it!

89
00:07:18.500 --> 00:07:23.391
Start by renaming the 'arg1' parameter
to something about the reflects its meaning

90
00:07:23.903 --> 00:07:25.951
We'll call it distance

91
00:07:27.487 --> 00:07:29.000
To keep things simple 
we're going to assume 

91
00:07:29.000 --> 00:07:31.583
all people are situated on a line

92
00:07:32.351 --> 00:07:34.655
A one-dimensional coordinate system

93
00:07:35.423 --> 00:07:38.495
We can always introduce proper geo locations later

94
00:07:39.007 --> 00:07:40.000
We'll place Sean in the center

94
00:07:40.000 --> 00:07:43.359
and Lucy 15 metres away from Sean

95
00:07:45.407 --> 00:07:48.735
Notice that the number 15
does not appear anywhere in our code

96
00:07:49.247 --> 00:07:54.879
The value 15 is automatically passed
from the Gherkin step into the step definition

97
00:07:54.900 --> 00:07:56.000
If you're curious

97
00:07:56.000 --> 00:08:00.767
that's the '\d' in the
pattern of the step definition

98
00:08:01.200 --> 00:08:05.119
We'll explain regular expressions
in detail in a future lesson

99
00:08:08.191 --> 00:08:10.500
To implement this step
we need to create a couple of 

99
00:08:10.500 --> 00:08:14.079
person objects with
the specified distance between them

100
00:08:14.335 --> 00:08:15.871
We could write it like this

101
00:08:18.00 --> 00:08:22.300
Now we have two instances
of person one representing Lucy

102
00:08:22.300 --> 00:08:24.319
and one representing Sean

103
00:08:24.831 --> 00:08:28.415
If you run Cucumber we'll see
a compilation error from Ruby

104
00:08:28.550 --> 00:08:31.231
We need to define our person class

105
00:08:33.023 --> 00:08:36.351
Let's give our solution a home
by creating a 'lib' directory

106
00:08:36.607 --> 00:08:42.751
We'll put our Shouty application
in a Ruby file called 'shouty.rb' in that directory

107
00:08:44.031 --> 00:08:46.800
Create the bare bones of our person

108
00:08:46.800 --> 00:08:52.000
just enough to satisfy the API
that we know we need

108
00:08:52.000 --> 00:08:55.295
from the code we've written
in our step definitions

110
00:08:57.599 --> 00:09:02.719
For now, we'll just require the
Shouty application from our 'steps.rb' file

111
00:09:02.975 --> 00:09:07.327
In a later lesson, we'll talk more
about how to organize this code a bit better

112
00:09:09.375 --> 00:09:14.239
When we run the scenario again
the first step is green!

113
00:09:17.055 --> 00:09:20.000
We'll follow the same flow
to make the remaining two steps pass

113
00:09:20.000 --> 00:09:23.200
do a little bit of domain modeling,
write the code we wish we had,

114
00:09:23.200 --> 00:09:26.783
make it compile, and run the scenario

115
00:09:28.831 --> 00:09:33.183
In the second step definition,
we want to tell Sean to shout something

116
00:09:36.300 --> 00:09:41.900
In order to send instructions to Sean,
we need to store him in an instance variable

117
00:09:41.900 --> 00:09:47.775
so that he'll be accessible
from all of our definitions, like this

118
00:09:53.500 --> 00:09:56.735
Our Person class needs a 'shout' method

119
00:09:57.503 --> 00:09:58.271
Let's add it!

120
00:10:00.100 --> 00:10:02.450
Don't worry about the implementation yet

121
00:10:02.450 --> 00:10:07.487
The important thing right now
is to discover the shape of our domain model

122
00:10:08.767 --> 00:10:12.500
The last step definition is where
we implement the check or assertion.

122
00:10:13.000 --> 00:10:15.500
We'll verify that what Lucy has heard,

123
00:10:15.500 --> 00:10:18.495
is exactly the same
as what Sean shouted

124
00:10:20.500 --> 00:10:23.359
Once again we're going to
write the code we wish we had

125
00:10:24.200 --> 00:10:29.000
So we need a way to ask Lucy
what messages she's heard

126
00:10:29.000 --> 00:10:33.087
and we also need to know
what it was that Sean shouted

127
00:10:33.599 --> 00:10:38.975
We can record what Sean shouts
by storing it an instance variable

128
00:10:39.231 --> 00:10:41.279
as the When step runs

129
00:10:41.791 --> 00:10:44.500
This is a common pattern to use
in Cucumber step definitions

129
00:10:44.500 --> 00:10:47.900
when you don't want to repeat
the same test data in different 

130
00:10:47.900 --> 00:10:49.471
parts of a scenario

131
00:10:50.495 --> 00:10:53.567
Now we can use that value in the assertion check

132
00:10:54.847 --> 00:10:59.199
We also need to add a 'messages_heard' method to our Person class

133
00:10:59.711 --> 00:11:00.991
Let's do that now

134
00:11:05.087 --> 00:11:08.000
We run 'cucumber' again and

135
00:11:08.000 --> 00:11:09.951
whoops!

136
00:11:10.207 --> 00:11:15.000
Undefined method 'messages_heard'
for nil class steps line 15

137
00:11:15.500 --> 00:11:17.300
It looks like

138
00:11:17.300 --> 00:11:23.775
we forgot to set Lucy as an instance variable

139
00:11:24.031 --> 00:11:29.407
Let's fix that and run the test again

140
00:11:32.991 --> 00:11:35.039
This is great!

141
00:11:35.295 --> 00:11:40.500
Whenever we do BDD, getting to our
first failing test is a milestone

142
00:11:40.500 --> 00:11:46.303
Seeing the test fail, proves that it is
capable of detecting errors in our code

143
00:11:46.559 --> 00:11:51.935
Never trust an automated test that
you haven't seen fail!

144
00:11:53.200 --> 00:11:56.850
Now all we have to do is write
the code to make it pass

145
00:11:56.850 --> 00:11:58.591
That's the easy bit!

146
00:12:00.127 --> 00:12:02.943
In this case we're going to cheat

147
00:12:04.223 --> 00:12:07.295
We have a one line fix that will
make the scenario pass

148
00:12:08.063 --> 00:12:10.300
It's not a particularly

149
00:12:10.300 --> 00:12:12.671
future-proof implementation

150
00:12:13.951 --> 00:12:15.487
Can you guess what it is?

151
00:12:18.500 --> 00:12:20.000
I'll show you

152
00:12:21.631 --> 00:12:24.703
Hmm, there. I told you it
wasn't very future-proof!

153
00:12:25.471 --> 00:12:30.591
Still, the fact that such a poor
implementation can pass our tests

155 
00:12:30.847 --> 00:12:33.407
shows us that we need to work on our tests

156
00:12:33.919 --> 00:12:36.100
A more comprehensive set of scenarios would

156
00:12:36.100 --> 00:12:38.783
force us to write a better implementation

157
00:12:40.100 --> 00:12:43.135
This is the essence of
behaviour-driven development

158
00:12:43.391 --> 00:12:46.719
Examples of behaviour drive the development

159
00:12:49.279 --> 00:12:53.000
So we know we need more scenarios
and a better solution

159
00:12:53.000 --> 00:12:55.000
Instead of writing a note on our to-do list

160
00:12:55.000 --> 00:12:56.959
let's write another failing scenario

161
00:13:00.031 --> 00:13:02.200
Now when we come back to this code
we can just run the tests

161
00:13:02.200 --> 00:13:05.919
and Cucumber will remind us
what we need to do next

162
00:13:06.300 --> 00:13:07.711
We're done for the day!

163
00:13:08.200 --> 00:13:10.200
Go make yourself a cup of tea

164
00:13:12.000 --> 00:13:14.000
Captions created by Jayson Smith for Cucumber Ltd.